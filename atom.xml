<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Young‘s River</title>
  
  <subtitle>一个正能量的程序员，喜欢码字，热爱运动，向往自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://issacyoung.cn/"/>
  <updated>2021-04-05T09:04:51.486Z</updated>
  <id>http://issacyoung.cn/</id>
  
  <author>
    <name>Issac Young</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一步一步之Java中的池化技术</title>
    <link href="http://issacyoung.cn/2021/04/04/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E4%B9%8BJava%E4%B8%AD%E7%9A%84%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://issacyoung.cn/2021/04/04/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E4%B9%8BJava%E4%B8%AD%E7%9A%84%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/</id>
    <published>2021-04-04T06:43:51.000Z</published>
    <updated>2021-04-05T09:04:51.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><blockquote><p>池化技术是性能调优的重要措施，思想是对象放到池子里，使用的时候从池子拿到对象，用完的时候归还对象，降低资源分配以及释放的开销，从而提升性能。实际项目中，每天都在使用池化技术。</p></blockquote><a id="more"></a><h3 id="池化技术种类"><a href="#池化技术种类" class="headerlink" title="池化技术种类"></a>池化技术种类</h3><ul><li>对象池：通过复用对象，减少对象创建、垃圾回收的开销</li><li>线程池：通过复用线程，提升性能</li><li>连接池：如数据库连接池/Redis连接池/HTTP连接池，通过复用TCP连接减少创建和释放连接的时间来提升性能</li></ul><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>维护一些很大、创建很慢的对象，提升性能</li><li>缺点：有学习成本，添加代码复杂度</li></ul><h3 id="对象池框架-Commons-Pool2"><a href="#对象池框架-Commons-Pool2" class="headerlink" title="对象池框架 - Commons-Pool2"></a>对象池框架 - Commons-Pool2</h3><ul><li>Apache 开源的对象池框架</li></ul><h4 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h4><p>对象池</p><ul><li>BaseObjectPool 抽象类，用来扩展自己的对象池</li><li>ErodingObjectPool 腐蚀对象池</li><li>GenericObjectPool 一个可配置的通用对象池实现</li><li>ProxiedObjectPool 代理一个其他的对象池，并基于动态代理（支持JDK代理和CGLib代理），返回一个代理的对象，强化池化对象的控制，比如防止在归还该对象后，还在继续使用该对象</li><li>SoftReferenceObjectPool 基于软引用的对象池</li><li>SynchronizedObjectPool 代理一个其他的对象池，并为其提供线程安全的能力</li></ul><h4 id="KeyedObjectPool"><a href="#KeyedObjectPool" class="headerlink" title="KeyedObjectPool"></a>KeyedObjectPool</h4><p>通过key找对象</p><ul><li>ErodingKeyedObjectPool </li><li>GenericKeyedObjectPool</li><li>ProxiedKeyedObjectPool</li><li>SynchronizedObjectPool</li></ul><h4 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h4><p>工厂模式，创建&amp;管理PooledObject</p><ul><li>BasePooledObjectFactory，抽象类，用于扩展自己的PooledObjectFactory</li><li>PoolUtils.SynchronizedPooledObjectFactory，内部类，代理一个其他的PooledObjectFactory，实现线程同步</li></ul><p>核心api</p><ul><li>makeObject 创建一个对象实例，并将其包装成一个PooledObject</li><li>destroyObject 销毁对象</li><li>validateObject 校验对象，确保对象池返回的对象是OK的</li><li>activateObject 重新初始化对象</li><li>passivateObject 取消初始化对象</li></ul><h4 id="PooledObject"><a href="#PooledObject" class="headerlink" title="PooledObject"></a>PooledObject</h4><p>包装原有池化对象</p><ul><li>DefaultPooledObject 包装原始对象，实现监控（创建时间、使用时间）、状态跟踪等</li><li>PooledSoftReference 进一步包装，用来跟SoftReferenceObjectPool配合使用</li></ul><p>状态</p><ul><li>idle 对象在队列中，并空闲</li><li>allocated 使用中（即出借中）</li><li>evicition 对象在队列中，正在进行驱逐测试</li><li>eviction_return_to_head 对象驱逐测试通过后，放回队列头部</li><li>validation 对象当前在队列中，空闲校验中</li><li>validation_preallocated 对象不在队列中，空闲校验中</li><li>validation_return_to_head 对象不在队列中，检验通过后放回头部</li><li>invalid 对象失效，驱逐测试失败、检验失败、对象销毁，都会将对象设置为 invalid</li><li>abandoned 驱逐中，如果上次使用时间超过removeAbandonedTimeout 的配置，则将其标记为 abandoned 。标记为abandoned的对象即变成invalid</li><li>returning 对象归还池中</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;池化&quot;&gt;&lt;a href=&quot;#池化&quot; class=&quot;headerlink&quot; title=&quot;池化&quot;&gt;&lt;/a&gt;池化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;池化技术是性能调优的重要措施，思想是对象放到池子里，使用的时候从池子拿到对象，用完的时候归还对象，降低资源分配以及释放的开销，从而提升性能。实际项目中，每天都在使用池化技术。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://issacyoung.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://issacyoung.cn/tags/java/"/>
    
      <category term="pooled object" scheme="http://issacyoung.cn/tags/pooled-object/"/>
    
  </entry>
  
  <entry>
    <title>java高频面试题</title>
    <link href="http://issacyoung.cn/2021/03/12/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://issacyoung.cn/2021/03/12/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-11T23:57:40.000Z</published>
    <updated>2021-03-14T12:42:53.146Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文档用于记录自己面试过程中遇到的高频的java面试题，无标准答案，仅凭自己的语言记录作为回顾作用。</p></blockquote><a id="more"></a><h2 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h2><ol><li><p>java 线程的状态</p><p>线程，程序处理的最小单元，以看病就医的流程处理参照，挂号、等待、门口等待、看病、离开诊室，新建、就绪、执行、阻塞、死亡。</p></li><li><p>进程和线程的区别，进程间如何通信，线程间如何通讯</p><p>进程是操作系统调度执行，线程是进程负责调度；进程资源独立，线程有共享资源。</p><p>进程通信通过socket，线程间通讯通过共享变量、notify/wait。</p></li><li><p>HashMap 的数据结构？如何实现的。和 HashTable，ConcurrentHashMap 的区别</p><p>数据结构是数组+链表+红黑树，存放在数组中，key 哈希映射上数组的key，value 存放在相应的数组。数组存放的对象是链表或者红黑树，当存放数量小于8为链表，超过则转成红黑树。HashTable 是线程安全，不允许null key，通过 synchronized 实现线程安全；ConcurrentHashMap 通过分段锁实现线程安全。</p></li><li><p>Cookie 和 Session 区别</p><p>Cookie 是客户端缓存，Session是服务端缓存。</p></li><li><p>索引有什么用？如何建索引？</p><p>索引提升查询性能。建索引的原则：唯一键、查询列、条件列、分组列、排序列、区分度大的列、长度小的列、最左匹配。</p></li><li><p>ArrayList 是如何实现？ArrayList 和 LinkedList 的区别？ArrayList 如何实现扩容。</p><p>ArrayList 内部维护一个可扩容的对象数组，当前容量*1.5，如果小于最小容量的要求，则取最小容量，如果大于最大容量，则取最大容量。同 LinkedList 区别：</p><ol><li>ArrayList 实现是数组，LinkedList 是链表</li><li>ArrayList 适合检索，LinkedList 适合插入、删除</li></ol></li><li><p>equals 方法实现</p><p>相应的需要实现 hashCode 方法，否则不满足等价性，添加到 HashSet 会报错</p></li><li><p>面向对象</p><p>复用、多态</p></li><li><p>线程状态， BLOCKED 和 WAITING 有什么区别</p></li><li><p>JVM如何加载字节码文件</p><p>加载 class 文件到JVM内存，读取静态数据转换成方法区运行的数据结构，在堆中生成一个Class对象；</p><p>链接，将java类的二进制合并到JVM运行状态</p><ol><li>验证，加载类信息符合规范</li><li>准备：正式为类变量（static变量）分配内存并设置类变量初始值</li><li>解析：虚拟机常量池的符号引用替换成字节引用</li></ol><p>初始化：</p><ol><li>执行 <cinit>方法</li><li>发现父类未初始化，优先初始化父类</li><li>保证加锁和同步</li></ol><p>ClassLoader 装载类时，除非显示使用另一个ClassLoader，该类所依赖及引用的类也有这个ClassLoader载入。</p></li><li><p>JVM GC，GC算法</p><p>标记-整理，标记-清除，分代。标记，判断是否可达对象。</p></li><li><p>什么情况下出现 Full GC，什么情况下出现 youngGC</p><p>老年代空间不足，放不下新生代晋升对象或新创建对象，System.gc。</p><p>新生代判断老年代最大的连续空间是否大于新生代的所有对象总空间。</p></li><li><p>JVM 内存模型</p><p>程序计数器、虚拟机方法栈、本地方法栈、堆、方法区、元空间</p></li><li><p>Java 运行时数据区</p></li><li><p>事务的实现原理</p><p>并发控制技术，乐观并发控制、悲观并发控制；</p><p>基于锁的并非控制：</p><p>共享锁，事务t对数据a加共享锁，其他事务只能对a加共享锁，不能加排它锁；</p><p>排它锁，事务t对数据a加排它锁，其他事务不能加锁。</p><p>基于时间戳的并发控制</p><p>基于有效性检查的并发控制</p><p>基于快照隔离的并发控制。</p></li><li><p>CopyOnWriteArrayList 实现原理</p><p>ArrayList 线程安全的变体，数据没有变化，读的同一个容器的数据；数据发生变化，copy一个容器副本，往新的容器添加数据，赋给旧的容器地址。添加过程中，读取数据，仍读到旧容器数据。</p></li><li><p>深克隆和浅克隆</p><p>浅克隆只对值类型属性拷贝，对引用类型复制指针。深克隆，复写clone方法，对引用类型属性做递归克隆。</p></li><li><p>事务隔离级别</p><p>未提交读、已提交读、可重复读、串行化</p></li><li><p>事务的四个关键属性（ACID）</p><p>A - Atomic 原子性</p><p>C - Consistenty 一致性</p><p>I - Idenpenty 隔离性</p><p>D - Durablity 持久化</p></li></ol><h2 id="技术深度"><a href="#技术深度" class="headerlink" title="技术深度"></a>技术深度</h2><ol><li><p>类的实现原理，jdk源码解释</p></li><li><p>HTTP协议</p><p>应用层协议，无状态。流程如下：</p></li><li><p>TCP协议</p><p>网络层协议，建立连接，三次握手：客户端A发送同步包请求 syn=1，seq=12345678，服务端接收到同步请求，发送确认同步包 syn=1,seq=87654321,ack=1,ack_number=12345679，客户端A收到确认包，确认ack_number回发同步包，syn=1,seq=56789,ack=1,ack_numer=87654322到服务端，建立连接，传输数据。四次挥手，全双工。</p></li><li><p>一致性Hash算法</p><p>分布式算法，用于负载均衡，解决将key-value均匀分配到众多 server上。虚拟节点，保证一致性。</p><ul><li>平衡性，哈希的结果尽可能分布到所有的缓冲</li><li>单调性</li><li>平滑性</li></ul><p>原理：</p><ol><li>建立环形hash空间，value 值映射到 32位的key值上</li><li>服务器（节点）映射到hash空间</li><li>对象映射到服务节点</li></ol><p>cache较少，对象不能均匀映射到 cache，虚拟节点，一个实际节点对于若干个“虚拟节点”。</p></li><li><p>类加载器如何卸载字节码</p></li><li><p>IO 和 NIO区别，NIO优点</p><p>IO同步阻塞，NIO同步非阻塞，NIO吞吐更高，能最大程度的利用cpu，利用 selector 监控 channel 数据传输，单线程。</p></li><li><p>Java 线程池的实现原理，keepAliveTime等参数的作用</p><p>池化，保证线程复用，以及可管理。维护一个任务队列、线程容器，如果有新任务进来，线程数未达到核心线程数，则新建线程处理任务；如果线程达到核心线程数，则任务进入阻塞队列等待，直至有空闲线程处理任务；如果任务队列也满了，则执行拒绝策略。keepAliveTime，线程空闲状态下保留的时间。</p></li><li><p>HTTP 连接池实现原理</p></li><li><p>数据库连接池原理</p><p>池化，保证连接复用，每次需要连接从池中borrow连接，用完连接return。</p></li><li><p>数据库实现原理</p><p>程序管理、索引管理、日志管理、数据存储</p></li></ol><h2 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a>技术框架</h2><ol><li><p>看过哪些开源框架的源码</p><p>springboot ，围绕启动事件说明启动流程，如何做到自动装配。</p></li><li><p>为什么要用 Redis，Redis有哪些优缺点？Redis 如何实现扩容？</p><p>Redis 是分布式缓存中间件，内存读写、单线程、多路复用nio、存储结构简单，单节点理论上支持10w qps，支持主从、集群；</p><p>缺点，主从同步延迟；</p><p>集群，使用代理，读写分离，一致性 Hash扩容</p></li><li><p>Netty 如何使用线程池，为什么这么使用？</p><p>分为 workerGroup 和 bossGroup；</p><p>bossGroup负责监控端口，处理TCP连接；</p><p>workerGroup负责处理IO，监控selector，监听注册的channel的IO就绪事件，单线程执行，保证Channel的pipeline 执行顺序；提高性能，提高cpu利用率</p></li><li><p>为什么要用Spring，Spring 优缺点？</p><p>Spring IOC，依赖注入，AOP切面，优点是框架成熟，缺点配置繁琐。</p></li><li><p>SpringIOC容器初始化流程</p><p>读取bean配置注册到 beanDefinistry 中，根据bean定义反射出bean实例，放到bean容器中，如果有beanPostProcessor ，需要执行相应的before和after方法</p></li><li><p>Spring  IOC 实现原理，为什么可以通过 byName 和 byType 找到bean？</p></li><li><p>SPring AOP实现原理</p><p>基于 jdk 动态代理和 cglib。通过 @Aspect 注解设置切面类，@PointCut 切面点，@Around切面方法</p></li><li><p>消息中间件如何实现的，技术难点？</p><p>异步通讯，解耦，并发缓冲。</p></li><li><p>Zookeeper 实现原理，以及选主算法</p><p>基于 算法。选主过程，保证集群是单数节点，发起投票，得到票数超过半数的选为leader。</p></li><li><p>为什么要用配置中心，配置中心如何实现的？</p></li></ol><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><ol><li><p>如何搭建一个高可用系统</p><p>nginx+ha+lvs ，cdn，redis，rocketmq，异步化调用，垂直切分、水平切分，分库分表。</p></li><li><p>哪些设计模式可以增加系统的可扩展性</p><p>策略模式、模版模式、适配器模式、组合模式等</p></li><li><p>介绍设计模式，如模版模式、命令模式、策略模式、适配器模式、桥接模式、装饰模式、观察者模式、状态模式、访问模式</p></li><li><p>抽象能力，怎么提高研发效率？</p><p>拒绝重复</p></li><li><p>什么是高内聚低耦合</p><p>高内聚，模块职责独立，互不干扰；低耦合，模块与模块之间接口的复杂度。</p></li><li><p>什么情况下用接口？什么情况下用消息？</p><p>模块依赖程度高，必须等待其他模块的结果返回。</p></li><li><p>如果AB两个系统互相依赖，如何解除依赖？</p></li><li><p>如何写一篇设计文档，目录是什么？</p></li><li><p>什么场景应该拆分系统？什么场景应该合并系统</p></li><li><p>系统和模块的区别，分别在什么场景下使用</p></li></ol><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><ol><li><p>分布式事务，两阶段提交</p><p>准备阶段：事务协调者给每个参与者发送 Prepare 消息，每个参与者要么直接返回失败，要么本地执行事务，但不提交；</p><p>提交阶段：事务协调者收到参与者有失败的消息，给每个参与者发送Rollback，否则Commit。</p><p>协调者很重要。</p></li><li><p>如何实现分布式锁</p><p>Mysql的行锁、redis的setnx、zookeeper的瞬时有序节点</p></li><li><p>如何实现分布式Session</p><p>redis</p></li><li><p>如何保证消息的一致性</p></li><li><p>负载均衡</p></li><li><p>正向代理（客户端代理）和反向代理（服务端代理）</p></li><li><p>CDN实现原理</p></li><li><p>介绍下 PAXOS 协议</p></li><li><p>介绍下 Zookeeper 的ZAB协议？如何选举LEADER？</p></li></ol><h2 id="实战能力"><a href="#实战能力" class="headerlink" title="实战能力"></a>实战能力</h2><ol><li><p>有没有处理过线上问题？出现内存泄漏，CPU利用率标高，应用无响应如何处理的？</p></li><li><p>开发中有没有遇到什么技术问题？如何解决？</p></li><li><p>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能</p></li><li><p>新浪微博是如何实现把微博推给订阅者</p></li><li><p>Google 是如何在一秒内把搜索结果返回给用户的</p></li><li><p>12306网站的订票系统如何实现，保证不会票超卖</p></li><li><p>如何设计一个秒杀系统，保证只有纪委用户能买到某件商品</p></li><li><p>缓存失效如何解决？</p><p>bitmap，null存值</p></li><li><p>从数据库查询10g的数据并加载到内存中？</p></li><li><p>如何设计一个流控功能？</p></li></ol><h2 id="软能力"><a href="#软能力" class="headerlink" title="软能力"></a>软能力</h2><ol><li>如何学习一项新技术，学习java，重点学习什么</li><li>有关注哪些新技术</li><li>工作任务非常多非常杂如何处理</li><li>项目出现延迟如何处理</li><li>和同事设计思路不一样如何处理</li><li>如何保证开发质量</li><li>职业规划是什么？短期、长期目标是什么？</li><li>团队规划是什么</li><li>介绍下工作到现在的成长</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此文档用于记录自己面试过程中遇到的高频的java面试题，无标准答案，仅凭自己的语言记录作为回顾作用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="interview" scheme="http://issacyoung.cn/categories/interview/"/>
    
    
      <category term="java" scheme="http://issacyoung.cn/tags/java/"/>
    
      <category term="interview" scheme="http://issacyoung.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>一步步吃透注册中心</title>
    <link href="http://issacyoung.cn/2021/03/05/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%90%83%E9%80%8F%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://issacyoung.cn/2021/03/05/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%90%83%E9%80%8F%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2021-03-05T00:44:11.000Z</published>
    <updated>2021-03-06T06:29:51.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><blockquote><p>单体架构发展到微服务，服务间通信、服务的配置，如何保证高可用、数据一致性，则需要一个统一的注册中心。目前注册中心的实现方式有，eureka、zookeeper、nacos、consul等解决方案，实现原理各不相同，适合各自的场景。</p></blockquote><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><blockquote><p>eureka，源自希腊语，意思是“我找到了”，是netflix的开源组件，并且集成在 SpringCloud的家族里。</p></blockquote><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><ul><li>eureka server，提供服务注册和发现，多个Eureka Server之间会同步数据，做到状态同步</li><li>service provider，服务提供方，注册自身服务到 Eureka</li><li>service consumer，从 Eureka 获取服务注册列表</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注册中心&quot;&gt;&lt;a href=&quot;#注册中心&quot; class=&quot;headerlink&quot; title=&quot;注册中心&quot;&gt;&lt;/a&gt;注册中心&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;单体架构发展到微服务，服务间通信、服务的配置，如何保证高可用、数据一致性，则需要一个统一的注册中心
      
    
    </summary>
    
    
      <category term="java" scheme="http://issacyoung.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://issacyoung.cn/tags/java/"/>
    
      <category term="springboot" scheme="http://issacyoung.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="http://issacyoung.cn/2021/03/04/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://issacyoung.cn/2021/03/04/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2021-03-04T14:55:14.000Z</published>
    <updated>2021-03-07T13:05:22.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><blockquote><p>又将之前的个人网站捡了回来，作为自己持续学习的一个记录。年逾30，愈发地觉得无计划地学习，已不似年轻时脑子好用，等过了三五天时常不记得学的内容。有计划的学习，一来压力不会太大，再者记录在案方便回溯。</p></blockquote><a id="more"></a><h2 id="Java高级应用"><a href="#Java高级应用" class="headerlink" title="Java高级应用"></a>Java高级应用</h2><blockquote><p>怎么理解这个高级应用？个人总结而言，凡是去重抽象的操作都可以理解为高级应用。集合、池化技术、动态代理、进程通信等等</p></blockquote><ul><li>并发</li><li>io</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><blockquote><p>吃透 SpringBoot 对于如何快速构建一个可读性高、易扩展的web服务非常重要，我们常常陷入到业务的crud之中，继而在重复劳动中消磨时光，我以为敲代码本身的乐趣在于仿真和去重。</p></blockquote><h2 id="分布式系统中间件"><a href="#分布式系统中间件" class="headerlink" title="分布式系统中间件"></a>分布式系统中间件</h2><blockquote><p>这个是面试的高频点，也是作为一个合格的架构师所必须熟悉的。如何才能熟稔于心，必然是需要在日常工作中反复练习、应用，触类旁通。</p></blockquote><ul><li><p>注册中心</p><ul><li>eureka</li><li>nacos</li><li>zookeeper</li></ul></li><li><p>服务间通信</p><ul><li>feign</li><li>dubbo</li></ul></li><li><p>消息中间件</p><ul><li>RocketMq</li><li>Kafka</li></ul></li><li><p>缓存中间件</p><ul><li>Redis</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习计划&quot;&gt;&lt;a href=&quot;#学习计划&quot; class=&quot;headerlink&quot; title=&quot;学习计划&quot;&gt;&lt;/a&gt;学习计划&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;又将之前的个人网站捡了回来，作为自己持续学习的一个记录。年逾30，愈发地觉得无计划地学习，已不似年轻时脑子好用，等过了三五天时常不记得学的内容。有计划的学习，一来压力不会太大，再者记录在案方便回溯。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://issacyoung.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://issacyoung.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一步步读SpringBoot源码</title>
    <link href="http://issacyoung.cn/2020/02/28/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BBSpringBoot%E6%BA%90%E7%A0%81/"/>
    <id>http://issacyoung.cn/2020/02/28/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BBSpringBoot%E6%BA%90%E7%A0%81/</id>
    <published>2020-02-28T00:49:18.000Z</published>
    <updated>2021-04-04T03:11:43.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote><p>为神马读源码？知其然知其所以然，触类旁通，究其原理，自我折磨的过程中，反复咀嚼、思考。SpringBoot 原旨是为了快速开发网站，其一网站，访问指定服务器的资源，现如今资源大多是数据库，从web诞生之始，一如既是；其二开发，不是运维、不是设计，在于提供给开发人员；其三，快速是相对而言，原有的 ssm过于繁琐，在于模块的整合、配置。</p></blockquote><a id="more"></a><p>查看官网的声明，SpringBoot的宗旨如下：</p><ul><li>创建单体的Spring应用</li><li>内置 Tomcat、Jetty、Undertow，无需部署war包</li><li>各种 starter 插件，简化配置</li><li>支持Spring和第三方jar自动装配</li><li>提供 metrics、health checks 额外的配置</li><li>无需xml</li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote><p>具体一步步使用无需赘述，具体看看如何创建单体Spring应用。</p></blockquote><ol><li><p>创建 pom 文件，引入依赖，这里以 maven 构建工程为例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot 指定默认版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add typical dependencies for a web application web依赖集合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Example<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的代码，启动main函数，web应用就起来了。看起来寥寥数语，究竟内藏什么玄呢？<code>@RestController</code> 给阅读代码的人提示被标注的类扮演处理 web 请求的角色， <code>@RequestMapping</code> 注解则扮演引路的角色，将访问路径映射到具体的方法上，同时 <code>@RestController</code>告诉 Spring 渲染的结果直接返回给调用者。</p><p><code>@EnableAutoConfiguration</code>注解则告诉 Spring Boot 是基于添加的依赖进行 Spring 配置，这里添加的是<code>spring-boot-starter-web</code>内置Tomcat、SpringMVC，表明即将启动的是个 web 工程。</p><p>至于 main 方法的逻辑，SpringApplication 调用 run 方法启动应用，装配 Spring，开启 Tomcat Web 工程，Example 作为主容器。</p></li><li><p>启动</p></li><li><p>构建可执行 jar</p><p>java 未提供装载嵌套的 jar包的标准方式，Spring Boot 提供了将程序依赖打包成一个压缩包的插件，<code>spring-boot-maven-plugin</code>，构建生成 xxx.jar 即是依赖的压缩包，可以直接运行。</p></li></ol><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>构建依赖体系，每一个版本的 springboot 集成特定版本的依赖包括第三方依赖。</p><p>继承父工程的依赖 <code>spring-boot-starter-parent</code>，提供了如下特征：</p><ul><li>java1.8编译</li><li>UTF-8编码</li><li>版本管理…</li></ul><ol><li><p>继承父starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加其他依赖无需指定版本号，如果需要覆盖父工程的集合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-data-releasetrain.version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">spring-data-releasetrain.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>&lt;dependencyManagement&gt;</code> 、<code>&lt;scope&gt;import&lt;/scope&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于有父依赖工程的项目，使用<code>dependecyManagement</code>，同时可以指定版本覆盖集合依赖</p></li></ol><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p>springboot 对代码框架没有严格要求，默认从 main 程序入口扫描实体类。<code>@SpringBootApplication</code> 相当于 <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p><code>@Configuration</code>修饰单个类相当于原来的 Spring xml ，同时 <code>@Import</code> 可以引入附加的配置类，<code>@ComponentScan</code>可以扫描 spring 组件，包括 <code>@Configuration</code>，当然 xml 文件也可以通过 <code>@ImportResource</code>引入。 </p><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>springboot 根据添加的依赖自动装配类到程序中，通过 <code>@EnableAutoConfiguration</code>或者 <code>@SpringBootApplication</code>修饰 <code>@Configuration</code>类。</p><p>exclude 可以指定排除某个类的自动装配。</p><h3 id="实体类和依赖注入"><a href="#实体类和依赖注入" class="headerlink" title="实体类和依赖注入"></a>实体类和依赖注入</h3><p>通过 <code>@Autowired</code> 可以修饰构造器注入，如果只有一个构造器，可以忽略。</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>相当于 <code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>、<code>@Configuration</code>三者集合。</p><h3 id="Developer-Tools"><a href="#Developer-Tools" class="headerlink" title="Developer Tools"></a>Developer Tools</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springboot 利用缓存机制提高性能，比如：静态资源，开发环境可以利用 developer tools 关闭缓存。在类文件发生修改时自动重启服务，可以指定排除的文件目录，也可以指定额外的监控目录。</p><h2 id="系统初始化器"><a href="#系统初始化器" class="headerlink" title="系统初始化器"></a>系统初始化器</h2><p>ApplicationContextInitalizer ，spring容器刷新之前回调函数。</p><p>SpringFactoriesLoader </p><p>从类路径jar包读取特定文件实现拓展类的载入。</p><p>上下文刷新refresh方法前调用</p><p>一般设置 web 环境变量</p><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>监听器模式。</p><h2 id="Bean-解析"><a href="#Bean-解析" class="headerlink" title="Bean 解析"></a>Bean 解析</h2><p>xml注册bean</p><p>注解方式</p><ul><li>@Component</li><li>FactoryBean，@Configuration</li><li>实现 BeanDefinitionRegistryPostProcessor</li><li>实现 ImportBeanDefinitionRegistrar</li></ul><p>refresh方法</p><ul><li><p>prefresh</p><ul><li>容器状态设置</li><li>初始化属性设置</li><li>必备属性校验</li></ul></li><li><p>obtainFreshBeanFactory</p><ul><li>设置beanFactory序列化id</li><li>获取beanFactory</li></ul></li><li><p>prepareBeanFactory</p><ul><li>设置beanFacotru属性</li><li>设置后置处理器</li></ul></li><li><p>postProccessBeanFactory</p><ul><li>子类重写以在beanFacotry创建后处理</li></ul></li><li><p>invokeBeanFactoryPostProcessors</p><ul><li>调用 BeanDefinitionRegistryPostProcessor 实现向容器内添加bean的定义</li><li>调用 BeanFactory</li></ul></li><li><p>registerBeanPostProcessors</p><ul><li>找到 BeanPostProcessor 实现</li><li>注册到容器</li></ul></li><li><p>initApplicationEventMulticaster</p><ul><li>初始化事件广播器</li></ul></li><li><p>registerListeners</p><ul><li>添加事件到广播器</li><li>执行早起事件</li></ul></li><li><p>finishBeanFactoryInitialization</p></li></ul><h3 id="Bean-实例化解析"><a href="#Bean-实例化解析" class="headerlink" title="Bean 实例化解析"></a>Bean 实例化解析</h3><p>围绕 BeanDefinition，最常见的 RootBeanDefinition</p><p>refresh方法流程</p><h2 id="Banner解析"><a href="#Banner解析" class="headerlink" title="Banner解析"></a>Banner解析</h2><h2 id="属性配置解析"><a href="#属性配置解析" class="headerlink" title="属性配置解析"></a>属性配置解析</h2><ul><li>Spring Aware介绍</li></ul><h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><ol><li>DevTools</li><li>测试环境 @TestPropertySource</li><li>测试环境 properties 属性</li><li>命令行参数</li><li>SPRING_APPLICATION_JOSN 属性</li><li>ServletConfig初始化参数</li><li>ServletContext</li><li>JDNI</li><li>Java系统属性</li><li>操作系统环境变量</li><li>RadomValuePropertySource</li><li>jar包外的 application-{profile}.properties</li><li>jar包内的 application-{profile}.properties</li><li>jar包外的 application.properties</li><li>jar包内的 application.properties</li><li>@PropertySource</li><li>默认属性</li></ol><h3 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h3><p>Bean 感知不到容器的存在，需要使用Spring容器的功能资源。使用 Aware，Bean 和容器强耦合。</p><p>常用的 Aware ： EnvironmentAware、ApplicationContextAware、BeanFactoryAware。</p><p>调用原理：</p><ul><li>doCreateBean</li><li>initalizeBean</li><li>invokeAwareMethods</li><li>applyBeanPostProcessorBeforeInitialization</li><li>ApplicationContextAwareProssor</li></ul><h3 id="Environment-解析"><a href="#Environment-解析" class="headerlink" title="Environment 解析"></a>Environment 解析</h3><h2 id="Spring-Boot-特征"><a href="#Spring-Boot-特征" class="headerlink" title="Spring Boot 特征"></a>Spring Boot 特征</h2><p><code>SpringApplication.run</code> 静态方法启动。</p><h3 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h3><p><code>$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</code> 可以查询启动日志</p><h3 id="个性化-banner"><a href="#个性化-banner" class="headerlink" title="个性化 banner"></a>个性化 banner</h3><p>在类路径下添加 <code>banner.txt</code>，或者指定<code>spring.banner.location</code> 指定文件，同时可以指定banner字符集<code>spring.banner.charset</code>。除了文本，也支持 <code>banner.gif</code>、<code>banner.jpg</code> 类路径下的图片，或者指定 banner图片<code>spring.banner.image.localtion</code></p><h3 id="事件和监听器"><a href="#事件和监听器" class="headerlink" title="事件和监听器"></a>事件和监听器</h3><p>Spring 框架中，<code>ContextRefreshedEvent</code>在上下文创建后创建，对于上下文创建之前的事件不能通过 <code>@Bean</code> 注册，可以通过 <code>SpringApplication.addListeners(...)</code>。</p><ol><li><code>ApplicationStartingEvent</code>，在注册监听器和初始化器操作外所有启动进程之前</li><li><code>ApplicationEnvironmentPreparedEvent</code>，<code>Environment</code> 使用时，但上下文创建之前</li><li><code>ApplicatioPreparedEvent</code> ，bean definitions 装载之后，refresh启动之前</li><li><code>ApplicationStartedEvent</code>，上下文刷新之后，application 和 command-line runner 调用之前</li><li><code>ApplicationReadyEvent</code>，application 和 command-line runner 调用之后，提示服务准备处理请求</li><li><code>ApplicationFailedEvent</code>，启动过程有异常</li></ol><h3 id="Web-Environment"><a href="#Web-Environment" class="headerlink" title="Web Environment"></a>Web Environment</h3><ul><li><code>AnnotationConfigServletWebServerApplicationContext</code> 使用了这个上下文类表示 Spring MVC</li><li><code>AnnotationConfigReactiveWebServerApplicationContext</code>，这个表示 Spring WebFlux</li><li>否则，使用<code>AnnotationConfigApplicationContext</code></li></ul><h3 id="ApplicationRunner-or-CommandLineRunner"><a href="#ApplicationRunner-or-CommandLineRunner" class="headerlink" title="ApplicationRunner or CommandLineRunner"></a>ApplicationRunner or CommandLineRunner</h3><p>在程序启动完成之前执行，两个接口都需要实现 run 方法。</p><h3 id="Application-Exit"><a href="#Application-Exit" class="headerlink" title="Application Exit"></a>Application Exit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitCodeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExitCodeGenerator <span class="title">exitCodeGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写退出错误码</span></span><br><span class="line">        <span class="keyword">return</span> ()-&gt;<span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Externalized-Configuration"><a href="#Externalized-Configuration" class="headerlink" title="Externalized Configuration"></a>Externalized Configuration</h3><p>外部化的配置，支持 properties、YAML、环境变量、命令行参数个性化配置。</p><h4 id="配置随机值"><a href="#配置随机值" class="headerlink" title="配置随机值"></a>配置随机值</h4><p><code>RandomValuePropertySource</code>注入随机值，适用于测试、密钥。</p><h4 id="Application-Property-Files"><a href="#Application-Property-Files" class="headerlink" title="Application Property Files"></a>Application Property Files</h4><p><code>java -jar xxx.jar --spring.config.name=myproject</code>，指定配置文件</p><p><code>java -jar xxx.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</code> </p><h4 id="Profile-specific-Properties"><a href="#Profile-specific-Properties" class="headerlink" title="Profile-specific Properties"></a>Profile-specific Properties</h4><p>指定环境变量，<code>application-{profile}.properties</code>，通过指定 spring.profiles.active 设置取的环境配置文件。</p><h4 id="Placeholders-in-Properties"><a href="#Placeholders-in-Properties" class="headerlink" title="Placeholders in Properties"></a>Placeholders in Properties</h4><p><code>application.properties</code> 可以填充环境变量或者之前定义的变量。</p><h4 id="Using-YAML-Instead-of-Properties"><a href="#Using-YAML-Instead-of-Properties" class="headerlink" title="Using YAML Instead of Properties"></a>Using YAML Instead of Properties</h4><p>更方便，广义的 JSON。</p><p>对于属性较多的节点，或者定义列表属性，书写更简洁。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dev.exapmle.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">another.example.com</span></span><br></pre></td></tr></table></figure><p>支持多环境指定。</p><p>缺点在于，不能被 <code>@PropertySource</code>加载，会跟环境变量冲突。</p><h4 id="Type-safe-Configuration-Properties"><a href="#Type-safe-Configuration-Properties" class="headerlink" title="Type-safe Configuration Properties"></a>Type-safe Configuration Properties</h4><p>类型安全配置，使用 <code>@Value(&quot;${property}&quot;)</code>比较笨重，特别是同多层级里多属性。springboot 提供了强类型bean映射配置类，支持非严格的绑定，<code>@Value</code>支持 SPEL 表达式。</p><p><code>@ConfigurationProperties</code> 处理环境配置，不建议注入其他bean。<code>@ConfigurationProperties</code> 可以通过 <code>@EnableConfigurationProperties</code> 注入，也可以通过 <code>@Component</code>。</p><h5 id="Third-Party-Configuration"><a href="#Third-Party-Configuration" class="headerlink" title="Third-Party Configuration"></a>Third-Party Configuration</h5><p>例如，redis的配置注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"another"</span>)</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnotherComponent <span class="title">anotherComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anotherComponent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Relaxed-Binding"><a href="#Relaxed-Binding" class="headerlink" title="Relaxed Binding"></a>Relaxed Binding</h5><p>属性绑定并不严格，支持中间杠的 Kabab 风格（官方建议）、标准的驼峰、下划线风格。</p><h5 id="Merging-Complex-Types"><a href="#Merging-Complex-Types" class="headerlink" title="Merging Complex Types"></a>Merging Complex Types</h5><p>list属性是完全覆盖，map则是按key覆盖。</p><h5 id="Properties-Conersion"><a href="#Properties-Conersion" class="headerlink" title="Properties Conersion"></a>Properties Conersion</h5><p>属性转换，时间单位、数据大小。</p><h5 id="ConfigurationProperties-Validation"><a href="#ConfigurationProperties-Validation" class="headerlink" title="@ConfigurationProperties Validation"></a>@ConfigurationProperties Validation</h5><p><code>@Validated 和@NotNull</code>，配合修饰，校验。</p><h3 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h3><p><code>@Configuration</code> 可以被 <code>@Profile</code>修饰，指定环境。可以<code>spring.profiles.include:</code>添加环境变量，多值。</p><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>springboot 使用通用的日志接口，实现开放，支持 <code>Java.Util.Logging</code>、<code>Log4J2</code>、<code>Logback</code>，也可以通过日志文件配置输出。</p><h4 id="Log-Format"><a href="#Log-Format" class="headerlink" title="Log Format"></a>Log Format</h4><ul><li>Date and Time</li><li>Log Level: ERROR、WARN、INFO、DEBUG、TRACE</li><li>Process ID</li><li><code>-</code>-<code>-</code> 用来区分实际的日志信息</li><li>Thread Name</li><li>Logger name：通常是源类文件</li><li>Log message</li></ul><h4 id="Console-Output"><a href="#Console-Output" class="headerlink" title="Console Output"></a>Console Output</h4><p>debug=true</p><h4 id="File-Output"><a href="#File-Output" class="headerlink" title="File Output"></a>File Output</h4><p>logging.file 或者 logging.path 设置文件输出文件或者目录</p><h4 id="Log-Levels"><a href="#Log-Levels" class="headerlink" title="Log Levels"></a>Log Levels</h4><p><code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code></p><h4 id="Custom-log-Configuration"><a href="#Custom-log-Configuration" class="headerlink" title="Custom log Configuration"></a>Custom log Configuration</h4><ul><li>Logback，<code>logback-spring.xml</code>、<code>logback-spring.groovy</code>、<code>logback.xml</code>、<code>logback.groovy</code></li><li>Log4j2，<code>log4j2-spring.xml</code>、<code>log4j2.xml</code></li><li>JDK，<code>logging.properties</code></li></ul><h4 id="Logback-Extensions"><a href="#Logback-Extensions" class="headerlink" title="Logback Extensions"></a>Logback Extensions</h4><p>logback.xml 已经预先加载，需要使用 <code>logback-spring.xml</code>或者定义<code>logging.config</code>。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>springboot 集成了Gson、Jackson、JSON-B，默认 jackson。</p><h3 id="Developing-Web-Applications"><a href="#Developing-Web-Applications" class="headerlink" title="Developing Web Applications"></a>Developing Web Applications</h3><p>使用内置 tomcat、jetty、undertow 创建 HTTP server。</p><h4 id="Spring-Web-MVC-Framework"><a href="#Spring-Web-MVC-Framework" class="headerlink" title="Spring Web MVC Framework"></a>Spring Web MVC Framework</h4><ul><li><p>Spring MVC Auto-configuration</p><ul><li><code>ContentNegotiatingViewResoler</code>和 <code>BeanNameViewResolver</code></li><li>自动注册，<code>Converter</code>、<code>GenericConverter</code>和<code>Formatter</code>。</li><li>支持 <code>HttpMessageConverters</code></li><li>自动注册 <code>MessageCodesResolver</code></li></ul></li><li><p>HttpMessageConverters</p></li><li><p>Custom JSON Serializers and Deserializers</p></li><li><p>MessageCodesResolver</p></li><li><p>Static Content</p></li><li><p>Welcome Page</p></li><li><p>Custom Favicon</p></li><li><p>Path Matching and Content Negotiation</p></li><li><p>ConfigurableWebBinddingInitalizer</p></li><li><p>Error Handling</p></li><li><p>CORS Support</p></li></ul><h4 id="Spring-WebFlux-Framework"><a href="#Spring-WebFlux-Framework" class="headerlink" title="Spring WebFlux Framework"></a>Spring WebFlux Framework</h4><p>异步非阻塞框架，响应式框架。</p><h4 id="Embedded-Servlet-Container-Support"><a href="#Embedded-Servlet-Container-Support" class="headerlink" title="Embedded Servlet Container Support"></a>Embedded Servlet Container Support</h4><p>支持 Tomcat、Jetty、Undertow</p><h3 id="Working-with-NoSQL-Technologies"><a href="#Working-with-NoSQL-Technologies" class="headerlink" title="Working with NoSQL Technologies"></a>Working with NoSQL Technologies</h3><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>支持 Lettuce 和 Jedis 的客户端，默认是 Lettuce，也支持异步。</p><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><h4 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h4><h4 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h4><h3 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h3><h4 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h4><h4 id="JCache"><a href="#JCache" class="headerlink" title="JCache"></a>JCache</h4><h4 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h4><h4 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h4><h4 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h4><p>java8重写 guava cache。</p><h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><p>消息系统，支持 JMS、ActiveMQ、RabbitMQ、Kafka</p><h3 id="Calling-REST-Services-with-RestTemplate"><a href="#Calling-REST-Services-with-RestTemplate" class="headerlink" title="Calling REST Services with RestTemplate"></a>Calling REST Services with <code>RestTemplate</code></h3><h3 id="Calling-REST-Services-with-WebClient"><a href="#Calling-REST-Services-with-WebClient" class="headerlink" title="Calling REST Services with WebClient"></a>Calling REST Services with <code>WebClient</code></h3><h3 id="Creating-Your-Own-Auto-Configuration"><a href="#Creating-Your-Own-Auto-Configuration" class="headerlink" title="Creating Your Own Auto-Configuration"></a>Creating Your Own Auto-Configuration</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为神马读源码？知其然知其所以然，触类旁通，究其原理，自我折磨的过程中，反复咀嚼、思考。SpringBoot 原旨是为了快速开发网站，其一网站，访问指定服务器的资源，现如今资源大多是数据库，从web诞生之始，一如既是；其二开发，不是运维、不是设计，在于提供给开发人员；其三，快速是相对而言，原有的 ssm过于繁琐，在于模块的整合、配置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://issacyoung.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://issacyoung.cn/tags/java/"/>
    
      <category term="SpringBoot" scheme="http://issacyoung.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>一步步之Discruotor I</title>
    <link href="http://issacyoung.cn/2020/02/24/%E4%B8%80%E6%AD%A5%E6%AD%A5%E4%B9%8BDiscruotor-I/"/>
    <id>http://issacyoung.cn/2020/02/24/%E4%B8%80%E6%AD%A5%E6%AD%A5%E4%B9%8BDiscruotor-I/</id>
    <published>2020-02-24T04:03:30.000Z</published>
    <updated>2020-03-10T00:33:18.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Discruptor-高性能队列"><a href="#Discruptor-高性能队列" class="headerlink" title="Discruptor 高性能队列"></a>Discruptor 高性能队列</h1><p>Discruptor 是一个高性能的异步框架，可以理解为线程间通信的高效低延迟的内存消息队列。而这里说的消息队列，不同于类似 RocketMQ 之类的分布式队列。早期用于英国外汇交易 LMAX ，单线程系统可支撑每秒处理600万订单。目前有很多成熟的项目使用 Disruptor ，比方说 Log4j 2、Camel等。</p><a id="more"></a><p>队列的底层实现是数组、链表或者堆，而堆表示有优先级的</p><h1 id="对比-J-U-C-工具"><a href="#对比-J-U-C-工具" class="headerlink" title="对比 J.U.C 工具"></a>对比 J.U.C 工具</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Discruptor-高性能队列&quot;&gt;&lt;a href=&quot;#Discruptor-高性能队列&quot; class=&quot;headerlink&quot; title=&quot;Discruptor 高性能队列&quot;&gt;&lt;/a&gt;Discruptor 高性能队列&lt;/h1&gt;&lt;p&gt;Discruptor 是一个高性能的异步框架，可以理解为线程间通信的高效低延迟的内存消息队列。而这里说的消息队列，不同于类似 RocketMQ 之类的分布式队列。早期用于英国外汇交易 LMAX ，单线程系统可支撑每秒处理600万订单。目前有很多成熟的项目使用 Disruptor ，比方说 Log4j 2、Camel等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Discruptor" scheme="http://issacyoung.cn/tags/Discruptor/"/>
    
      <category term="一步步" scheme="http://issacyoung.cn/tags/%E4%B8%80%E6%AD%A5%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>如何一步步创建个人网站</title>
    <link href="http://issacyoung.cn/2020/02/22/%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <id>http://issacyoung.cn/2020/02/22/%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</id>
    <published>2020-02-22T14:44:35.000Z</published>
    <updated>2020-02-24T04:04:49.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何一步步创建个人网站"><a href="#如何一步步创建个人网站" class="headerlink" title="如何一步步创建个人网站"></a>如何一步步创建个人网站</h1><blockquote><p>早就想建一个人网站，用于知识积累、感悟心得的记录，得空利用半天周末的时间完成了这个夙愿。</p></blockquote><a id="more"></a><h2 id="获取个人域名"><a href="#获取个人域名" class="headerlink" title="获取个人域名"></a>获取个人域名</h2><p>推荐阿里云申请域名，需要有认证的阿里云账号，审核时间很快，具体步骤阿里云平台有详细的文档。</p><h2 id="Github建立个人仓库"><a href="#Github建立个人仓库" class="headerlink" title="Github建立个人仓库"></a>Github建立个人仓库</h2><p>在 github 代码仓库新建一个仓库，仓库名称参考 *<em>用户名.github.io *</em>，用户名为 github 账号。</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>注意 Node 的版本，Node 下载地址：<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a>。</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>Hexo 是个人博客网站的框架。注意 Hexo 的版本对应的 Node 版本，之前安装因为 Node 版本与 Hexo 版本不一致，有些 Node 的语法不支持，耗费了不少时间。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>基于命令行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 hexo 客户端</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> npm 安装访问境外网站比较慢，推荐设置 npm 镜像为淘宝镜像</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证 npm 的镜像地址</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果还是很慢，可以考虑用 yarn 安装</span></span><br><span class="line">yarn global add hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">hexo -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化 hexo 博客项目</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建博客</span></span><br><span class="line">hexo new/n "我的第一篇个人网站博客"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成/编译</span></span><br><span class="line">hexo generate/n </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务预览</span></span><br><span class="line">hexo server/s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署</span></span><br><span class="line">hexo deploy/d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除缓存</span></span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="Hexo-测试"><a href="#Hexo-测试" class="headerlink" title="Hexo 测试"></a>Hexo 测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new "我的第一篇个人网站博客"</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务 localhost:4000</span></span><br></pre></td></tr></table></figure><p>打开浏览器输入地址，访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><p>需要将 github 的仓库地址同 Hexo 关联起来，打开项目目录的配置文件 <code>_config.yml</code>，修改部署配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/IssacYoung2013/issacyoung2013.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装 Git 部署插件，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>重新部署服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时访问个人仓库路径，<strong>用户名.github.io</strong>，个人博客网站就可以在网络上访问了。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>在阿里云申请的域名做解析设置</p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><p>参考文章 <a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何一步步创建个人网站&quot;&gt;&lt;a href=&quot;#如何一步步创建个人网站&quot; class=&quot;headerlink&quot; title=&quot;如何一步步创建个人网站&quot;&gt;&lt;/a&gt;如何一步步创建个人网站&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;早就想建一个人网站，用于知识积累、感悟心得的记录，得空利用半天周末的时间完成了这个夙愿。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="网站" scheme="http://issacyoung.cn/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="个人博客网站" scheme="http://issacyoung.cn/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    
      <category term="Hexo" scheme="http://issacyoung.cn/tags/Hexo/"/>
    
  </entry>
  
</feed>
