<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Young‘s River</title>
  
  <subtitle>一个正能量的程序员，喜欢码字，热爱运动，向往自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://issacyoung.cn/"/>
  <updated>2021-03-04T15:11:18.628Z</updated>
  <id>http://issacyoung.cn/</id>
  
  <author>
    <name>Issac Young</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习计划</title>
    <link href="http://issacyoung.cn/2021/03/04/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://issacyoung.cn/2021/03/04/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2021-03-04T14:55:14.000Z</published>
    <updated>2021-03-04T15:11:18.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><blockquote><p>又将之前的个人网站捡了回来，作为自己持续学习的一个记录。年逾30，愈发地觉得无计划地学习，已不似年轻时脑子好用，等过了三五天时常不记得学的内容。有计划的学习，一来压力不会太大，再者记录在案方便回溯。</p></blockquote><a id="more"></a><h2 id="Java高级应用"><a href="#Java高级应用" class="headerlink" title="Java高级应用"></a>Java高级应用</h2><blockquote><p>怎么理解这个高级应用？个人总结而言，凡是去重抽象的操作都可以理解为高级应用。集合、池化技术、动态代理、进程通信等等</p></blockquote><ul><li>并发</li><li>io</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="分布式系统中间件"><a href="#分布式系统中间件" class="headerlink" title="分布式系统中间件"></a>分布式系统中间件</h2><blockquote><p>这个是面试的高频点，也是作为一个合格的架构师所必须熟悉的。如何才能熟稔于心，必然是需要在日常工作中反复练习、应用，触类旁通。</p></blockquote><ul><li><p>注册中心</p><ul><li>eureka</li><li>nacos</li><li>zookeeper</li></ul></li><li><p>服务间通信</p><ul><li>feign</li><li>dubbo</li></ul></li><li><p>消息中间件</p><ul><li>RocketMq</li><li>Kafka</li></ul></li><li><p>缓存中间件</p><ul><li>Redis</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习计划&quot;&gt;&lt;a href=&quot;#学习计划&quot; class=&quot;headerlink&quot; title=&quot;学习计划&quot;&gt;&lt;/a&gt;学习计划&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;又将之前的个人网站捡了回来，作为自己持续学习的一个记录。年逾30，愈发地觉得无计划地学习，已不似年轻时脑子好用，等过了三五天时常不记得学的内容。有计划的学习，一来压力不会太大，再者记录在案方便回溯。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://issacyoung.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://issacyoung.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一步步读SpringBoot源码</title>
    <link href="http://issacyoung.cn/2020/02/28/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BBSpringBoot%E6%BA%90%E7%A0%81/"/>
    <id>http://issacyoung.cn/2020/02/28/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BBSpringBoot%E6%BA%90%E7%A0%81/</id>
    <published>2020-02-28T00:49:18.000Z</published>
    <updated>2021-03-04T15:10:25.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-初识"><a href="#SpringBoot-初识" class="headerlink" title="SpringBoot 初识"></a>SpringBoot 初识</h1><p>SpringBoot 是 spring 提供的一站式web快速开发部署框架，摆脱 SSM（Spring、Spring-MVC、Mybatis） 繁琐的配置流程，为微服务应运而生。目前有SpringBoot 1.X 和 2.X版本，2.X要求 Java8+，1.x java7 即可。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table><thead><tr><th>工具/框架</th><th>特点</th></tr></thead><tbody><tr><td>Java8</td><td>Lambda、Stream、接口默认&amp;静态方法、方法引用、重复注解、类型注解、日期&amp;时间API、base64加解密API、数组并行操作、JVM新增元空间</td></tr><tr><td>Maven3.3</td><td>依赖管理、项目构建、生命周期、插件机制</td></tr><tr><td>IntelliJ IDEA</td><td>强大的整合能力、提示功能快速、便捷、快捷键方便</td></tr><tr><td>Mysql</td><td>性能卓越、服务稳定、开放源代码、社区活跃</td></tr></tbody></table><h2 id="对比-SSM-框架"><a href="#对比-SSM-框架" class="headerlink" title="对比 SSM 框架"></a>对比 SSM 框架</h2><p>spring、spring mvc、mybatis三个框架的整合，搭建耗时比较长。</p><blockquote><p>引入 jar 包-〉配置 web.xml-〉配置 applicationContext.xml-》配置 mybatis-&gt;配置spring-mvc dispatchServlet -〉编写服务类、编写控制类</p></blockquote><p>springboot 整合了三个框架，只需要在 application.yml 中配置就可以，耗时短，配置简洁，不注重版本管理，只需要引入相应的 starter。</p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>the source for modern java 现代Java的源泉</p><p><img src="http://q6eziv0nt.bkt.clouddn.com/spring.png" alt="sppring"></p><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>基于 web mvc 的 web 框架。</p><p><img src="http://q6eziv0nt.bkt.clouddn.com/spring-mvc.png" alt="spring-mvc"></p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>ORM 框架，关系型数据对象转为 Java 对象。</p><h2 id="Spring-Boot-启动流程"><a href="#Spring-Boot-启动流程" class="headerlink" title="Spring Boot 启动流程"></a>Spring Boot 启动流程</h2><ul><li>一行代码启动</li><li>框架初始化</li><li>框架启动</li><li>自动化装配</li></ul><h3 id="框架初始化步骤"><a href="#框架初始化步骤" class="headerlink" title="框架初始化步骤"></a>框架初始化步骤</h3><ol><li>配置资源加载器</li><li>配置 primarySource | 启动类</li><li>应用环境的检测</li><li>配置系统初始化器</li><li>配置应用监听器</li><li>配置 main 方法所在的类</li></ol><h3 id="启动框架"><a href="#启动框架" class="headerlink" title="启动框架"></a>启动框架</h3><ol><li>计时器开始计时</li><li>Headless 模式赋值</li><li>发送 ApplicationStartingEvent</li><li>配置环境模块 Environment</li><li>发送ApplicationEnvironmentPreparedEvent</li><li>打印 Banner</li><li>创建应用上下文对象</li><li>初始化失败分析器</li><li>关联springboot组件与应用上下文对象 </li><li>发送ApplicationContextInitalizedEvent</li><li>加载source到context</li><li>发送ApplicationPreaparedEvent</li><li>刷新上下文</li><li>计时器停止计时</li><li>发送ApplicationStartEvent</li><li>调用框架启动拓展类</li><li>发送ApplicationReadyEvent</li></ol><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><ol><li>收集配置文件的配置工厂类</li><li>加载组件工厂</li><li>注册组件内定义的bean</li></ol><h1 id="系统初始化器"><a href="#系统初始化器" class="headerlink" title="系统初始化器"></a>系统初始化器</h1><h3 id="SpringContextInitializer介绍"><a href="#SpringContextInitializer介绍" class="headerlink" title="SpringContextInitializer介绍"></a>SpringContextInitializer介绍</h3><ul><li>ApplicationContextInitalizer</li><li>Spring容器刷新之前执行的一个回调函数</li><li>向SpringBoot容器中注册属性</li><li>继承接口自定义实现</li></ul><h3 id="自定义初始化器"><a href="#自定义初始化器" class="headerlink" title="自定义初始化器"></a>自定义初始化器</h3><ul><li><p>实现 ApplicationContextInitializer 接口，spring.factories 填写接口实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=com.issac.spring.boot.demo.initializer.FirstInitializer</span><br></pre></td></tr></table></figure></li><li><p>实现 ApplicationContextInitializer 接口，SpringApplication 初始化时手动设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication application = <span class="keyword">new</span> SpringApplication(DemoApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        application.addInitializers(<span class="keyword">new</span> SecondInitializer());</span><br><span class="line">        application.run(args</span><br></pre></td></tr></table></figure></li><li><p>实现 ApplicationContextInitializer 接口，配置文件中注册，被 DelegatingApplicationContextInitalizer 发现，优先级为0</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context:</span><br><span class="line">  initializer:</span><br><span class="line">    classes: com.issac.spring.boot.demo.initializer.ThirdInitializer</span><br></pre></td></tr></table></figure></li></ul><h3 id="SpringFactioriesLoader介绍"><a href="#SpringFactioriesLoader介绍" class="headerlink" title="SpringFactioriesLoader介绍"></a>SpringFactioriesLoader介绍</h3><ul><li>框架内部使用工厂加载机制</li><li>从classpath下多个jar包读取文件并初始化</li><li>文件必须是 key-value</li><li>key 是全限定名（抽象类|接口），value是实现，多个实现用,分割</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>从特定位置加载实现类到上下文</p><h1 id="监听器解析"><a href="#监听器解析" class="headerlink" title="监听器解析"></a>监听器解析</h1><h2 id="监听器模式"><a href="#监听器模式" class="headerlink" title="监听器模式"></a>监听器模式</h2><ul><li>事件</li><li>监听器</li><li>广播器</li><li>触发机制</li></ul><h2 id="SpringBoot监听器实现"><a href="#SpringBoot监听器实现" class="headerlink" title="SpringBoot监听器实现"></a>SpringBoot监听器实现</h2><h3 id="系统监听器介绍"><a href="#系统监听器介绍" class="headerlink" title="系统监听器介绍"></a>系统监听器介绍</h3><ul><li>ApplicationListener</li><li>ApplicationEventMulticaster</li></ul><h3 id="系统事件"><a href="#系统事件" class="headerlink" title="系统事件"></a>系统事件</h3><ul><li>ApplicationEvent</li></ul><h3 id="事件的发送顺序"><a href="#事件的发送顺序" class="headerlink" title="事件的发送顺序"></a>事件的发送顺序</h3><ol><li>starting</li><li>prepared 容器属性已加载</li><li>started</li><li>environmentPrepared</li><li>contextInitializerd</li><li>ready</li></ol><h3 id="监听器注册"><a href="#监听器注册" class="headerlink" title="监听器注册"></a>监听器注册</h3><ol><li>spring.factories</li><li>SpringFactoriesLoader 载入</li></ol><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="获取监听器列表"><a href="#获取监听器列表" class="headerlink" title="获取监听器列表"></a>获取监听器列表</h4><h4 id="通用触发条件"><a href="#通用触发条件" class="headerlink" title="通用触发条件"></a>通用触发条件</h4><ul><li>supportEventType</li><li>supportSourceType</li></ul><h2 id="自定义监听器"><a href="#自定义监听器" class="headerlink" title="自定义监听器"></a>自定义监听器</h2><ul><li>实现ApplicationListener接口，spring.factories中填写</li><li>实现ApplicationListener接口，手动设置</li><li>实现ApplicationListener接口，application.yml 配置 context.listener.classes</li><li>实现SmartApplicationListener接口，重写 supportsEventType</li></ul><h1 id="bean-解析"><a href="#bean-解析" class="headerlink" title="bean 解析"></a>bean 解析</h1><h2 id="IoC思想"><a href="#IoC思想" class="headerlink" title="IoC思想"></a>IoC思想</h2><p>对象间互相依赖，多齿轮依赖</p><p>使用一个大的容器，所有齿轮都依赖这个容器，容器之间互相不存在耦合。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>松耦合</li><li>灵活性</li><li>可维护性</li></ul><h2 id="bean-配置方式"><a href="#bean-配置方式" class="headerlink" title="bean 配置方式"></a>bean 配置方式</h2><h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><ul><li><p>无参构造</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"17"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"issac"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"courseList"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>English<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>Math<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>Chinese<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>有参构造</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"issac"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"27"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"English,Math,Chinese"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>工厂方法（静态）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.issac.spring.boot.demo.ioc.xml.AnimalFactory"</span> <span class="attr">id</span>=<span class="string">"dog"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">"getAnimal"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"type"</span> <span class="attr">value</span>=<span class="string">"dog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实例工厂</p></li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li><p>@Compontent 声明</p></li><li><p>配置类使用 @Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dog"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 FacotryBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Animal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Animal<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 BeanDefinitionRegistryPostProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanRegister</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        rootBeanDefinition.setBeanClass(Monkey<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"monkey"</span>,rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 ImortBeanDefinitionRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanImport</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> </span>&#123;</span><br><span class="line">        RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        rootBeanDefinition.setBeanClass(Bird<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"bird"</span>,rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import</span>(MyBeanImport<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DemoApplicationTest2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="refresh-解析"><a href="#refresh-解析" class="headerlink" title="refresh 解析"></a>refresh 解析</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>bean 配置读取</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><ul><li>容器状态设置</li><li>初始化属性设置</li><li>检查必备属性是否存在</li></ul><h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h3><ul><li>刷新 beanFactory</li><li>获取 DefaultListenableBeanFactory</li></ul><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><ul><li>设置 beanFactory 属性</li><li>添加后置处理器</li><li>设置忽略的自动装配接口</li><li>注册组件</li></ul><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><ul><li>遍历 beanFactory 中的 BeanDefinitionRegistryPostProcessor 实现</li><li>判断是否实现 PriorityOrdered 接口</li><li>是-》添加到 currentRegistryProcessors，添加到 processedBeans</li><li>否-》对集合 currentRegistryProcessors 进行排序</li><li>将上述结果添加到 registryProcessors</li></ul><h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h3><ul><li>找到 BeanPostProcessor 的实现</li><li>排序后注册到容器中</li></ul><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h3><ul><li>添加容器监听事件器至事件广播器中</li><li>派发早期事件</li></ul><h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><ul><li>初始化单实例对象</li></ul><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h3><ul><li>初始化生命周期处理器</li><li>调用生命周期处理器 onRefresh 方法</li><li>发布 ContextRefreshedEvent 事件</li><li>JMX 相关处理</li></ul><h2 id="Bean-实例化解析"><a href="#Bean-实例化解析" class="headerlink" title="Bean 实例化解析"></a>Bean 实例化解析</h2><h3 id="BeanDefinition-介绍"><a href="#BeanDefinition-介绍" class="headerlink" title="BeanDefinition 介绍"></a>BeanDefinition 介绍</h3><ul><li>一个对象在 Spring 中的描述，RootBeanDefinition 是其最常见的实现</li><li>通过操作 BeanDefinition 实例化对象</li></ul><h3 id="自定义实例化-Bean"><a href="#自定义实例化-Bean" class="headerlink" title="自定义实例化 Bean"></a>自定义实例化 Bean</h3><ul><li>继承 InstantiationAwareBeanPostProcessor</li><li>实现 postProcessBeforeInstantiation</li></ul><h3 id="实例流程"><a href="#实例流程" class="headerlink" title="实例流程"></a>实例流程</h3><ul><li>start -&gt; getBean -&gt; doGetBean -&gt; getSingleton -&gt; CreateBean -&gt; instantiate-&gt; instantiateBean -&gt; crreateBeanInstance -&gt; doCreateBean -&gt; resolveBeforeInstantiation-&gt; populateBean -&gt; instalizeBean -&gt; end</li></ul><h1 id="Banner-解析"><a href="#Banner-解析" class="headerlink" title="Banner 解析"></a>Banner 解析</h1><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h3 id="默认-banner"><a href="#默认-banner" class="headerlink" title="默认 banner"></a>默认 banner</h3><p>不需要设置</p><h3 id="文字-banner"><a href="#文字-banner" class="headerlink" title="文字 banner"></a>文字 banner</h3><ul><li>设置 banner.txt </li><li>设置 spring.banner.location</li></ul><h3 id="图片-banner"><a href="#图片-banner" class="headerlink" title="图片 banner"></a>图片 banner</h3><ul><li>设置 banner.jpg(.gif | .png)</li><li>设置 spring.banner.image.location</li></ul><h3 id="兜底-banner"><a href="#兜底-banner" class="headerlink" title="兜底 banner"></a>兜底 banner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication application = <span class="keyword">new</span> SpringApplication(DemoApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">application.setBanner(<span class="keyword">new</span> ResourceBanner(<span class="keyword">new</span> ClassPathResource(<span class="string">"favourite.txt"</span>)));</span><br></pre></td></tr></table></figure><h3 id="关闭-banner"><a href="#关闭-banner" class="headerlink" title="关闭 banner"></a>关闭 banner</h3><ul><li>设置 spring.main.banner-mode: off</li></ul><h2 id="banner-获取原理"><a href="#banner-获取原理" class="headerlink" title="banner 获取原理"></a>banner 获取原理</h2><ul><li>获取 banner <ul><li>getImageBanner 默认 banner.jpg(gif | .png)</li><li>getTextBanner 默认 banner.txt</li></ul></li><li>打印 banner</li></ul><h2 id="banner-输出原理"><a href="#banner-输出原理" class="headerlink" title="banner 输出原理"></a>banner 输出原理</h2><h3 id="默认输出"><a href="#默认输出" class="headerlink" title="默认输出"></a>默认输出</h3><ul><li>输出 banner 指定内容</li><li>获取版本信息</li><li>文本内容前后对齐</li><li>文本内容染色</li><li>输出文本内容</li></ul><h3 id="文字输出"><a href="#文字输出" class="headerlink" title="文字输出"></a>文字输出</h3><ul><li>获取 spring.banner.charset 设置字符集</li><li>获取文本内容</li><li>替换占位符</li><li>输出文本内容</li></ul><h3 id="图片输出"><a href="#图片输出" class="headerlink" title="图片输出"></a>图片输出</h3><ul><li>通过 spring.banner.image.* 设置属性</li><li>读取图片文件流</li><li>输出内容</li></ul><h1 id="启动加载器解析"><a href="#启动加载器解析" class="headerlink" title="启动加载器解析"></a>启动加载器解析</h1><h2 id="计时器介绍"><a href="#计时器介绍" class="headerlink" title="计时器介绍"></a>计时器介绍</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li>构造 StopWatch</li><li>start：业务校验 - 保存任务名-记录当前时间 </li><li>stop：业务校验 - 计算当前任务耗时 - 任务执行数+1 - 清空当前任务</li></ul><h3 id="代码优点"><a href="#代码优点" class="headerlink" title="代码优点"></a>代码优点</h3><ul><li>短小精悍</li><li>命名严谨</li><li>考虑周到</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ul><li>实现 CommandLineRunner </li></ul><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul><li>实现 ApplicationRunner</li></ul><h3 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h3><ul><li>通过 Order 值设置顺序</li><li>order 值相同ApplicationRunner 优先 </li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>传参不同</li><li>优先级不同</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p>添加 ApplicationRunner 实现到runners集合</p></li><li><p>添加 CommandLineRunner 实现到 runners 集合</p></li><li><p>对 runners 集合排序</p></li><li><p>依次遍历，调用 callRunners</p></li></ul><h1 id="属性配置解析"><a href="#属性配置解析" class="headerlink" title="属性配置解析"></a>属性配置解析</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>DevTools 全局配置</li><li>测试环境 @TestPropertySource 注解</li><li>测试环境 properties 属性</li><li>命令行参数</li><li>SPRING_APPLICATION_JSON 属性 <strong>配置后需要重启</strong></li><li>ServletConfig 初始化参数</li><li>ServletContext 初始化参数 server.port</li><li>JIDI 属性</li><li>JAVA 系统属性</li><li>操作系统环境变量</li><li>RandomValuePropertySource 随机值属性</li><li>jar包外的 application-{profile}.properties</li><li>jar包内的 application-{profile}.properties </li><li>jar 包外的 application.properties</li><li>jar 包内的 application.properties</li><li>@PropertySource 绑定配置</li><li>默认设置</li></ul><h2 id="Spring-Aware"><a href="#Spring-Aware" class="headerlink" title="Spring Aware"></a>Spring Aware</h2><ul><li><p>Spring 框架优点： Bean 感知不到容器的存在</p></li><li><p>使用场景：需要使用Spring容器的功能资源</p></li><li><p>引入Bean和容器强耦合</p></li></ul><h3 id="常用-Aware"><a href="#常用-Aware" class="headerlink" title="常用 Aware"></a>常用 Aware</h3><ul><li>BeanNameAware 获得容器中 bean名称</li><li>BeanClassLoaderAware 获得类加载器</li><li>BeanFactoryAware 获得bean创建工厂</li><li>EnvrionmentAware 获得环境变量</li><li>EmbeddedValueResolverAware 获得spirng容器记载的properties文件属性值</li><li>ResourceLoaderAware 获得资源加载器</li><li>ApplicationEventPublisherAware 获得应用事件发布器</li><li>MessageSourceAware 获得文本信息</li><li>ApplicationContextAware 获得应用上下文</li></ul><h3 id="Aware-调用"><a href="#Aware-调用" class="headerlink" title="Aware 调用"></a>Aware 调用</h3><ul><li>doCreateBean - InitializeBean - invokeAwareMethods - applyBeanPostProcessorsBeforeInitialization - ApplicationContextAwareProcessor</li></ul><h3 id="自定义实现-Aware"><a href="#自定义实现-Aware" class="headerlink" title="自定义实现 Aware"></a>自定义实现 Aware</h3><ul><li>定义一个接口实现 Aware</li><li>定义 set 方法</li><li>写一个 BeanPostProcessor 实现</li><li>改写 postProcessBeforeInitialization </li></ul><h2 id="Environment-解析"><a href="#Environment-解析" class="headerlink" title="Environment 解析"></a>Environment 解析</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><ul><li>AbstractEnvrionment#getProperty</li><li>PropertySourceResolver#getProperty</li><li>遍历PropertySources集合获取属性</li><li>Environment对象如何填充集合</li></ul><h3 id="getOrCreateEnvironment"><a href="#getOrCreateEnvironment" class="headerlink" title="getOrCreateEnvironment"></a>getOrCreateEnvironment</h3><ul><li>添加 servletConfigInitParams属性集</li><li>添加 servletContextInitParams 属性集</li><li>添加 Jndi 属性集</li><li>添加 systemProperties 属性集</li><li>添加 systemEnvironment 属性集</li></ul><h3 id="configureEnvironment"><a href="#configureEnvironment" class="headerlink" title="configureEnvironment"></a>configureEnvironment</h3><ul><li>添加 defaultProperties 属性集</li><li>添加 commandLineArgs 属性集</li></ul><h3 id="listeners-environmentPrepared"><a href="#listeners-environmentPrepared" class="headerlink" title="listeners.environmentPrepared"></a>listeners.environmentPrepared</h3><ul><li>添加 spring.application.json 属性集</li><li>添加 vcap 属性集</li><li>添加 random 属性集</li><li>添加 application-profile.(properties|yml)属性集</li></ul><h3 id="ConfigurationPropertySource-attach"><a href="#ConfigurationPropertySource-attach" class="headerlink" title="ConfigurationPropertySource.attach"></a>ConfigurationPropertySource.attach</h3><ul><li>添加 configurationProperties 属性集</li></ul><h3 id="ConfigurationClassParser"><a href="#ConfigurationClassParser" class="headerlink" title="ConfigurationClassParser"></a>ConfigurationClassParser</h3><ul><li>添加 @PropertySources 属性集</li></ul><h2 id="Spring-Profile"><a href="#Spring-Profile" class="headerlink" title="Spring Profile"></a>Spring Profile</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li>不同的配置参数绑定不同的环境</li></ul><h3 id="默认使用"><a href="#默认使用" class="headerlink" title="默认使用"></a>默认使用</h3><ul><li><p>application.properties</p></li><li><p>application-default.properties</p></li><li><p>application.profiles.default=defaults(不能定义在 application文件中)</p></li></ul><h3 id="激活使用"><a href="#激活使用" class="headerlink" title="激活使用"></a>激活使用</h3><ul><li>spring.profiles.active=xx</li><li>spring.profiles.active 与 default 互斥</li><li>spring.profiles.include=xxx,yyy</li></ul><h3 id="指定前缀名"><a href="#指定前缀名" class="headerlink" title="指定前缀名"></a>指定前缀名</h3><ul><li>spring.config.name=xxx 命令行</li></ul><h3 id="处理入口"><a href="#处理入口" class="headerlink" title="处理入口"></a>处理入口</h3><ul><li>ConfigurationApplicationListener#onApplicationEvent</li><li>postProcessEnvironment</li><li>addPropertySources</li><li>Loader.load</li></ul><h3 id="Load-逻辑"><a href="#Load-逻辑" class="headerlink" title="Load 逻辑"></a>Load 逻辑</h3><ul><li>读取 application-profile.xxx 文件</li><li>资源存在</li><li>loadDocuments 读取文件属性</li><li>将文件内激活的 profile 添加到profiles 集合中</li><li>将文件中定义的属性放在 loaded 中</li></ul><h3 id="addLoadedPropertySources"><a href="#addLoadedPropertySources" class="headerlink" title="addLoadedPropertySources"></a>addLoadedPropertySources</h3><ul><li>获得 environment 的 propertySource 集合对象 destination</li><li>遍历 loaded 集合</li><li>依次将集合的属性添加到 destination</li></ul><h1 id="异常报告器"><a href="#异常报告器" class="headerlink" title="异常报告器"></a>异常报告器</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul><li>功能：报告异常给到用户</li><li>实现类：LoggingFailureAnalysisReporter</li><li>实现方法：根据失败分析结果类构建错误信息输出</li></ul><h3 id="框架内实现"><a href="#框架内实现" class="headerlink" title="框架内实现"></a>框架内实现</h3><ul><li><p>run 方法</p></li><li><p>Collection<SpringBootExceptionReporter></p></li><li><p>getSpringFactoriesInstances</p></li><li><p>填充集合内容</p></li></ul><h3 id="reportException-实现"><a href="#reportException-实现" class="headerlink" title="reportException 实现"></a>reportException 实现</h3><ul><li>analyze 方法</li><li>遍历 analyze 集合能处理该异常的对象</li><li>report 方法</li><li>FailureAnalysisReporter 实现类报告异常</li></ul><h2 id="处理入口-1"><a href="#处理入口-1" class="headerlink" title="处理入口"></a>处理入口</h2><h3 id="handleRunFailure-逻辑"><a href="#handleRunFailure-逻辑" class="headerlink" title="handleRunFailure 逻辑"></a>handleRunFailure 逻辑</h3><ul><li><p>handleExitCode</p><ul><li>退出状态码为0正常退出，否则异常退出</li><li>发布 ExitCodeEvent 事件</li><li>记录 exitCode</li></ul></li><li><p>listeners.failed</p><ul><li>发布 ApplicationFailureEvent</li></ul></li><li><p>reportFailure</p><ul><li>SpringBootExceptionReporter  调用 reportException 方法</li><li>成功处理记录已处理</li></ul></li><li><p>context.close</p><ul><li>更改应用上下文状态</li><li>销毁单例bean</li><li>beanFactory 置为空</li><li>关闭 web 容器</li><li>移除  shutdownHook，jvm退出执行逻辑</li></ul></li><li><p>ReflectionUtils.rethrowRuntimeException(exception)</p><ul><li>重新抛出异常</li></ul></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>讲述下 SpringBoot 异常处理流程</li><li>SpringBoot 异常处理流程中有哪些注意事项</li><li>如何自定义实现 SpringBoot 异常报告器</li></ul><h1 id="配置类解析"><a href="#配置类解析" class="headerlink" title="配置类解析"></a>配置类解析</h1><h2 id="入口解析"><a href="#入口解析" class="headerlink" title="入口解析"></a>入口解析</h2><ul><li>refresh - invokeBeanFactoryPostProcessors - ConfigurationClassPostProcessor - postProcessBeanDefinitionRegistry</li></ul><h3 id="postProcessBeanDefinitionRegistry-逻辑"><a href="#postProcessBeanDefinitionRegistry-逻辑" class="headerlink" title="postProcessBeanDefinitionRegistry 逻辑"></a>postProcessBeanDefinitionRegistry 逻辑</h3><ul><li>获取 BeanDefinitionRegistry 的唯一id：registryId</li><li>检查一下 registyId 是否已处理过</li><li>添加 registyId 到已处理集合中</li><li>processConfigBeanDefinitions </li></ul><h2 id="执行逻辑解析"><a href="#执行逻辑解析" class="headerlink" title="执行逻辑解析"></a>执行逻辑解析</h2><h3 id="执行入口"><a href="#执行入口" class="headerlink" title="执行入口"></a>执行入口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 待处理的配置类</span></span><br><span class="line">    parser.parse(candidates);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>( !candidates.isEmpty())</span><br></pre></td></tr></table></figure><h3 id="循环体逻辑"><a href="#循环体逻辑" class="headerlink" title="循环体逻辑"></a>循环体逻辑</h3><ul><li>ConfingurationClassParser#parse</li><li>ConfingurationClassParser#validate 验证是否final、beanMethod是否合法</li><li>读取 BeanMethod 注册 BeanDefinition</li><li>处理新引入的 BeanDefinition</li></ul><h3 id="parse方法调用链"><a href="#parse方法调用链" class="headerlink" title="parse方法调用链"></a>parse方法调用链</h3><ul><li>ConfingurationClassParser#parse</li><li>同名parse方法</li><li>processConfigurationClass</li><li>doProcessConfigurationClass</li></ul><h3 id="doProcessConfigurationClass"><a href="#doProcessConfigurationClass" class="headerlink" title="doProcessConfigurationClass"></a>doProcessConfigurationClass</h3><ul><li>内部类</li><li>PropertySource</li><li>ComponentScan</li><li>Import</li><li>ImportResource</li><li>BeanMethod</li><li>接口默认方法</li><li>父类</li></ul><h2 id="核心方法解析"><a href="#核心方法解析" class="headerlink" title="核心方法解析"></a>核心方法解析</h2><h3 id="内部类处理"><a href="#内部类处理" class="headerlink" title="内部类处理"></a>内部类处理</h3><h3 id="PropertySource处理"><a href="#PropertySource处理" class="headerlink" title="PropertySource处理"></a>PropertySource处理</h3><ul><li>用法 @PropertySource({“demo.properties”})</li><li>遍历指定路径，替换占位符，加载资源</li><li>将资源添加到 environment 中</li></ul><h3 id="ComponentScan-处理"><a href="#ComponentScan-处理" class="headerlink" title="ComponentScan 处理"></a>ComponentScan 处理</h3><ul><li>@ComponentScan(basePackages={“pkgA”,”pkgB”},basePackageClasses={A.class,B.class})</li><li>没设置扫描路径的话使用配置类所在的路径</li><li>过滤顺序：excludeFilters -&gt; includeFilters -&gt; false</li></ul><h3 id="Import处理"><a href="#Import处理" class="headerlink" title="Import处理"></a>Import处理</h3><ul><li>ImportSelector.class &amp; DeferredImportSelector.class</li><li>处理以上两个接口实现 selectImports 返回的类名数组</li><li>DeferredImportSelector 接口调用优先级低于其他接口</li><li>处理ImportBeanDefinitionRegistrar 实现注册的bean</li><li>处理 @Import(A.class)</li></ul><h3 id="ImportResource处理"><a href="#ImportResource处理" class="headerlink" title="ImportResource处理"></a>ImportResource处理</h3><ul><li>ImportResource(“xyz.xml”)</li><li>将注解属性值放入 importedResoures中</li><li>后续 loadBeanDefinitionsForConfigurationClass加载定义的bean</li></ul><h3 id="BeanMethod处理"><a href="#BeanMethod处理" class="headerlink" title="BeanMethod处理"></a>BeanMethod处理</h3><ul><li>处理使用 @Bean的方法</li></ul><h3 id="接口默认处理"><a href="#接口默认处理" class="headerlink" title="接口默认处理"></a>接口默认处理</h3><ul><li>同 BeanMethod</li></ul><h4 id="父类处理"><a href="#父类处理" class="headerlink" title="父类处理"></a>父类处理</h4><ul><li>不能为 null</li><li>不能以 java 开头</li><li>尚未处理过</li></ul><h1 id="Servlet-容器启动解析"><a href="#Servlet-容器启动解析" class="headerlink" title="Servlet 容器启动解析"></a>Servlet 容器启动解析</h1><h2 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h2><h3 id="Apache-Tomcat"><a href="#Apache-Tomcat" class="headerlink" title="Apache Tomcat"></a>Apache Tomcat</h3><ul><li>轻量级web应用服务器</li><li>Tomcat 指定端口监听用户请求</li><li>Connector收到请求，转交给Container,Container由内部的 Engine 处理，根据请求的路径的 host 和 Context 转交 Servlet 处理，处理完根据路径返回用户</li><li>Tomcat 架构解析 &amp; Tomcat权威指南</li></ul><h3 id="启动前准备"><a href="#启动前准备" class="headerlink" title="启动前准备"></a>启动前准备</h3><ul><li>SpringApplication 构造方法</li><li>赋值webApplicationType属性</li><li>根据classpath下是否存在特定类来决定</li><li>SERVLET、REACTIVE、NONE</li><li>refresh方法</li><li>createApplicationContext方法</li><li>根据webApplicationType属性决定上下文</li><li>初始化DEFAULT_SERVLET_WEB_CONTEXT_CLASSS</li></ul><h3 id="webServer创建入口"><a href="#webServer创建入口" class="headerlink" title="webServer创建入口"></a>webServer创建入口</h3><ul><li>refreshContext</li><li>refresh</li><li>onRefresh</li><li>createWebServer</li></ul><h3 id="webServer创建"><a href="#webServer创建" class="headerlink" title="webServer创建"></a>webServer创建</h3><ul><li>getWebServerFactory</li><li>factory.getWebServer</li><li>设置 webServer 属性</li><li>initPropertySources</li></ul><h3 id="servlet-启动"><a href="#servlet-启动" class="headerlink" title="servlet 启动"></a>servlet 启动</h3><ul><li>refresh</li><li>finishRefresh</li><li>startWebServer</li><li>publishEvent</li></ul><h2 id="web容器工厂类加载解析"><a href="#web容器工厂类加载解析" class="headerlink" title="web容器工厂类加载解析"></a>web容器工厂类加载解析</h2><h2 id="web容器个性化配置解析"><a href="#web容器个性化配置解析" class="headerlink" title="web容器个性化配置解析"></a>web容器个性化配置解析</h2><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><ul><li>配置web容器属性如：server.xxx=xyz</li><li>注入到 ServerProperties 类中</li><li>自动配置类导入 WebServerFactoryCustomizer 实现类</li><li>ServerProperties 实现类的具体属性</li></ul><h3 id="工厂类初始化"><a href="#工厂类初始化" class="headerlink" title="工厂类初始化"></a>工厂类初始化</h3><ul><li>getWebServerFactory 获取具体 web 服务工厂类</li><li>对具体实现类调用 doGetBean 进行初始化</li><li>遍历 BeanPostProcessor 实现对 Bean 处理</li><li>进入 WebServerFactoryCustomizerBeanPostProcessor 实现方法</li></ul><h3 id="BeanPostProcessor-方法实现"><a href="#BeanPostProcessor-方法实现" class="headerlink" title="BeanPostProcessor 方法实现"></a>BeanPostProcessor 方法实现</h3><ul><li>postProcessBeforeInitizlization</li><li>getCustomizers()</li><li>获得所有的 WebServerFactoryCustomizer 实现类</li><li>依次调用实现类的 customize 方法进行定制处理</li></ul><h3 id="定制化流程"><a href="#定制化流程" class="headerlink" title="定制化流程"></a>定制化流程</h3><ul><li>ServletWebServerFactoryCustomizer#customize</li><li>构建 PropertyMapper 工具类</li><li>从 ServerProperties 属性中获取自定义设置</li><li>将自定义属性赋值给WebServerFactory</li><li>创建时应用到具体的 webServer 中</li></ul><h1 id="Springboot-starter-原理解析"><a href="#Springboot-starter-原理解析" class="headerlink" title="Springboot starter 原理解析"></a>Springboot starter 原理解析</h1><h2 id="conditional-注解介绍"><a href="#conditional-注解介绍" class="headerlink" title="conditional 注解介绍"></a>conditional 注解介绍</h2><ul><li>含义：基于条件的注解</li><li>作用：根据是否满足某一个特定条件来决定是否创建某个特定的Bean</li><li>意义：Springboot 实现自动配置的关键基础能力</li></ul><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><ul><li>@ConditionalOnBean @ConditionalOnMissingBean</li><li>@ConditionalOnClass @ConditionalOnMissingClass</li><li>@ConditionalOnWebApplication @ConditionalOnProperty</li><li>@ConditionalOnNotWebApplication @ConditionalOnJava</li></ul><h3 id="自定义-Conditional-注解实现"><a href="#自定义-Conditional-注解实现" class="headerlink" title="自定义 Conditional 注解实现"></a>自定义 Conditional 注解实现</h3><ul><li>实现一个自定义注解并且引入 Conditional 注解</li><li>实现 Condition 接口重写 matches 方法，符合条件返回 true</li><li>自定义注解引入 Condition 接口实现类</li></ul><h2 id="动手搭建-starter"><a href="#动手搭建-starter" class="headerlink" title="动手搭建 starter"></a>动手搭建 starter</h2><h3 id="starter介绍"><a href="#starter介绍" class="headerlink" title="starter介绍"></a>starter介绍</h3><ul><li>简介：可插拔插件</li><li>与 jar 包区别：starter 能实现自动配置</li><li>作用：大幅提升开发效率</li></ul><h3 id="常用-starter"><a href="#常用-starter" class="headerlink" title="常用 starter"></a>常用 starter</h3><ul><li>spring-boot-starter-data-redis</li><li>spring-boot-starter-web</li><li>spring-boot-starter-activemq</li></ul><h3 id="新建starter步骤"><a href="#新建starter步骤" class="headerlink" title="新建starter步骤"></a>新建starter步骤</h3><ul><li>新建 Springboot 项目</li><li>引入 spring-boot-autoconfigure</li><li>编写属性源及自动配置类</li><li>在 spring.factories 中添加自动配置类实现</li><li>maven 打包</li></ul><h3 id="使用-starter-步骤"><a href="#使用-starter-步骤" class="headerlink" title="使用 starter 步骤"></a>使用 starter 步骤</h3><ul><li>pom.xml 引入 starter</li><li>属性文件中配置属性</li><li>类中引用服务</li><li>调用服务能力</li></ul><h2 id="starter-原理解析"><a href="#starter-原理解析" class="headerlink" title="starter 原理解析"></a>starter 原理解析</h2><h3 id="starter自动配置类导入"><a href="#starter自动配置类导入" class="headerlink" title="starter自动配置类导入"></a>starter自动配置类导入</h3><ul><li>启动类 @SpringBootApplication</li><li>引入 Auto ConfigurationImportSeletor</li><li>ConfigurationClassParse 中处理</li><li>获取 spring.factories 中 EnableAutoConfiguration 实现</li></ul><h3 id="starter自动配置类过滤"><a href="#starter自动配置类过滤" class="headerlink" title="starter自动配置类过滤"></a>starter自动配置类过滤</h3><ul><li>@ConditionalOnProperty</li><li>OnPropertyCondition</li><li>getMatchOutcome</li><li>遍历注解属性判断 envrionment 中是否含有并值一致</li><li>返回比对结果</li></ul><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><ul><li><p>介绍下你熟悉的conditional 注解？</p></li><li><p>回答conditional 注解的原理</p></li><li><p>Springboot starter 有什么作用？熟悉有哪些</p></li><li><p>starter 自动配置类时如何引入到框架？</p></li><li><p>starter中自动配置类生效原理？</p></li></ul><h1 id="mybatis-starter-原理解析"><a href="#mybatis-starter-原理解析" class="headerlink" title="mybatis-starter 原理解析"></a>mybatis-starter 原理解析</h1><h2 id="mybatis-starter-介绍"><a href="#mybatis-starter-介绍" class="headerlink" title="mybatis-starter 介绍"></a>mybatis-starter 介绍</h2><h3 id="mybatis-starter作用"><a href="#mybatis-starter作用" class="headerlink" title="mybatis-starter作用"></a>mybatis-starter作用</h3><ul><li>自动检测工程中的 DataSource</li><li>创建并注册 SqlSessionFactory 实例</li><li>创建并注册 SqlSessionTemplate 实例</li><li>自动扫描 mappers</li></ul><h3 id="mybatis-starter-引入步骤"><a href="#mybatis-starter-引入步骤" class="headerlink" title="mybatis-starter 引入步骤"></a>mybatis-starter 引入步骤</h3><ul><li>引入 mybatis-starter mysql 两者 jar包</li><li>配置数据库连接属性</li><li>引入mybatis逆向工程插件及文件</li><li>配置 mybatis 工程属性</li><li>注解 MapperScan 或 Mapper 以扫描接口类</li></ul><h3 id="mapper-类扫描"><a href="#mapper-类扫描" class="headerlink" title="mapper 类扫描"></a>mapper 类扫描</h3><ul><li><p>MapperScannerRegistrarNotFoundConfiguration</p></li><li><p>AutoConbfiguredMapperScannerRegistrar | MapperScan</p></li><li><p>MApperScannerConfigure</p></li><li><p>扫描mapper接口注册到容器中</p></li><li><p>@MapperScan</p></li><li><p>@Mapper</p></li></ul><h3 id="mapper类生成"><a href="#mapper类生成" class="headerlink" title="mapper类生成"></a>mapper类生成</h3><ul><li>processBeanDefinitions</li><li>beanClass替换成MapperFatoryBean.class</li><li>MapperFactoryBean#getObject</li><li>MapperProxy对象</li><li>MapperProxy#invoke</li><li>MapperMethod#execute</li><li>根据数据库操作类型，调用 sqlsession 操作</li><li>返回执行结果</li></ul><h3 id="自动配置类导入"><a href="#自动配置类导入" class="headerlink" title="自动配置类导入"></a>自动配置类导入</h3><ul><li>mybatis-spring-boot-starter jar包</li><li>mybatis-spring-boot-autoconfigurre jar 包</li><li>META-INF/spring.factories 文件</li><li>MybatisAutoConfiguration</li></ul><h3 id="关键类注入"><a href="#关键类注入" class="headerlink" title="关键类注入"></a>关键类注入</h3><ul><li>SqlSessionFactory 单个数据库映射关系经编译后的内存镜像</li><li>SqlSessionTemplate 执行数据库操作的工具类</li></ul><h2 id="缓存使用指南"><a href="#缓存使用指南" class="headerlink" title="缓存使用指南"></a>缓存使用指南</h2><h3 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h3><ul><li>完全开源免费</li><li>支持数据持久化</li><li>支持多数据结构</li><li>支持数据备份</li></ul><h3 id="redis-starter-使用"><a href="#redis-starter-使用" class="headerlink" title="redis starter 使用"></a>redis starter 使用</h3><ul><li>spring-boot-starter-data-redis jar包</li><li>application.properties 文件定义 redis 相关属性</li><li>RedisConfiguration注入自定义 RedisTempalte </li><li>编写 RedisUtil 使用 RedisTemplate 增删改查</li></ul><h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><ul><li><p>讲解下 mybatis-starter 使用流程</p></li><li><p>mybatis 更新有哪几种方式</p><ul><li>根据条件、主键、全量更新、选择更新</li></ul></li><li><p>mapper 接口是如何被扫描到注册到容器中</p></li><li><p>mybatis-starter原理</p></li><li><p>springboot 如何和 redis 结合</p></li><li><p>缓存穿透、雪崩？如何防止</p></li></ul><h1 id="Spring-web-flux-解析"><a href="#Spring-web-flux-解析" class="headerlink" title="Spring web flux 解析"></a>Spring web flux 解析</h1><h2 id="web-flux-介绍"><a href="#web-flux-介绍" class="headerlink" title="web flux 介绍"></a>web flux 介绍</h2><ul><li>相比传统框架所解决的问题</li></ul><h3 id="同步阻塞式io模型"><a href="#同步阻塞式io模型" class="headerlink" title="同步阻塞式io模型"></a>同步阻塞式io模型</h3><p>每个请求对应容器thread处理</p><h3 id="异步非阻塞式io模型"><a href="#异步非阻塞式io模型" class="headerlink" title="异步非阻塞式io模型"></a>异步非阻塞式io模型</h3><p>耗时请求转交给 work线程组；提升吞吐量、伸缩性；</p><h3 id="web-flux-应用场景"><a href="#web-flux-应用场景" class="headerlink" title="web flux 应用场景"></a>web flux 应用场景</h3><ul><li>IO密集型，网关</li></ul><h3 id="与-springmvc-异同点"><a href="#与-springmvc-异同点" class="headerlink" title="与 springmvc 异同点"></a>与 springmvc 异同点</h3><ul><li>@Controller Reactive clients 、Tomcat 8+、Jetty、Undertow</li><li>spring mvc 命令式编程</li><li>spring webflux 调试不方便，学习成本，不支持关系型数据库阻塞式查询，对函数式编程友好；事件循环和并发模型；使用 netty</li></ul><h3 id="netty-优点"><a href="#netty-优点" class="headerlink" title="netty 优点"></a>netty 优点</h3><ul><li>API 使用简单、易上手</li><li>功能强大、支持多种主流协议</li><li>定制能力强，可扩展性高</li><li>性能高、综合性能最优</li><li>成熟稳定、久经考验</li><li>社区活跃、学习资料多</li></ul><h3 id="netty-selector-模型"><a href="#netty-selector-模型" class="headerlink" title="netty selector 模型"></a>netty selector 模型</h3><ul><li>多路复用</li></ul><h3 id="webflux使用建议"><a href="#webflux使用建议" class="headerlink" title="webflux使用建议"></a>webflux使用建议</h3><ul><li>当前项目正常，无需切换</li><li>在简单小项目中试用</li><li>谨慎在大型项目中使用</li></ul><h3 id="webflux-技术依赖"><a href="#webflux-技术依赖" class="headerlink" title="webflux 技术依赖"></a>webflux 技术依赖</h3><ul><li>Reactive Streams 反应式编程标准和规范</li><li>Reactor 基于 Reactive Streams 的反应式编程框架</li><li>WebFlux 以Reactor 为基础实现 Web 领域的反应式编程框架</li></ul><h3 id="Reactive-Stream"><a href="#Reactive-Stream" class="headerlink" title="Reactive Stream"></a>Reactive Stream</h3><ul><li>一套基于 jvm 面向流式类库的标准和规范</li><li>具有处理无限数量数据的能力</li><li>按序处理数据</li><li>异步非阻塞的传递数据</li><li>必须实现非阻塞的背压</li></ul><h3 id="api规范组件"><a href="#api规范组件" class="headerlink" title="api规范组件"></a>api规范组件</h3><ul><li>publisher 数据发布者</li><li>subscriber 数据订阅者</li><li>subscription 订阅信号</li><li>processor 处理器（包含了发布者和订阅者的混合体）</li></ul><h2 id="Reactor-指南"><a href="#Reactor-指南" class="headerlink" title="Reactor 指南"></a>Reactor 指南</h2><h3 id="Reactor-简介"><a href="#Reactor-简介" class="headerlink" title="Reactor 简介"></a>Reactor 简介</h3><ul><li>Spring 公司开发</li><li>符合 Reactive Streams 规范</li><li>侧重于 server 端的响应式编程框架</li><li>reactor-core（api） reactor-ips（高性能网络）</li></ul><h3 id="Java原有异步编程方式"><a href="#Java原有异步编程方式" class="headerlink" title="Java原有异步编程方式"></a>Java原有异步编程方式</h3><ul><li>Callbacks 异步方法采用一个 callback 作为参数，当结果出来后回调这个 callback，例如 swings 的 EventListener<ul><li>Callback Hell</li></ul></li><li>Futures 异步方法返回一个 Future<T> ,此时结果并不是立刻可以拿到，需处理结束之后可用<ul><li>多个 Future 组合不易</li><li>调用 Future#get 仍然会阻塞</li><li>缺乏对多个值的处理</li></ul></li></ul><h3 id="Reactor-的-publisher"><a href="#Reactor-的-publisher" class="headerlink" title="Reactor 的 publisher"></a>Reactor 的 publisher</h3><ul><li>实现 Flux Mono</li><li>Flux 代表一个包含 0..N 个元素的响应式序列</li><li>Mono 代表一个包含 0/1 个元素的结果</li></ul><h3 id="Reactor-操作符"><a href="#Reactor-操作符" class="headerlink" title="Reactor 操作符"></a>Reactor 操作符</h3><ul><li>map 操作符 对每个数据转换操作</li><li>flatMap 操作符元素序列</li><li>filter 过滤</li><li>zip 合并输出</li></ul><h3 id="reactor-和-java8-stream-区别"><a href="#reactor-和-java8-stream-区别" class="headerlink" title="reactor 和 java8 stream 区别"></a>reactor 和 java8 stream 区别</h3><ul><li>形似神不似</li><li>reactor push模式 服务端推送数据给客户端</li><li>stream pull 模式，客户端主动向服务端请求数据</li></ul><h3 id="reactor-创建线程方式"><a href="#reactor-创建线程方式" class="headerlink" title="reactor 创建线程方式"></a>reactor 创建线程方式</h3><ul><li>Schedulers.immediate() 当前线程</li><li>Schedulers.single() 可重用的单线程</li><li>Schedulers.elastic() 弹性线程池</li><li>Schedulers.parallel() 固定大小线程池</li><li>Schedulers.fromExecutorServic() 自定义线程池</li></ul><h3 id="线程切换总结"><a href="#线程切换总结" class="headerlink" title="线程切换总结"></a>线程切换总结</h3><ul><li>publishOn 将上游信号传给下游，同时改变后续的操作符的执行所在线程，直到下一个publishOn出现这个链上</li><li>subscribeOn 作用于向上的订阅链，无论处于操作链的什么位置，它都会影响到源头的线程执行环境，但不会影响到源头的线程执行环境，它不会影响到后续的 pubishOn</li></ul><h2 id="webflux-实践"><a href="#webflux-实践" class="headerlink" title="webflux 实践"></a>webflux 实践</h2><h3 id="实践内容"><a href="#实践内容" class="headerlink" title="实践内容"></a>实践内容</h3><p><strong>starter-web 排除 tomcat</strong> </p><ul><li>兼容 springmvc 写法</li><li>spring webflux 函数式写法</li><li>连接关系型数据库案例</li><li>连接非关系型数据库案例</li></ul><h2 id="webflux-解析"><a href="#webflux-解析" class="headerlink" title="webflux 解析"></a>webflux 解析</h2><h3 id="springmvc-处理流程"><a href="#springmvc-处理流程" class="headerlink" title="springmvc 处理流程"></a>springmvc 处理流程</h3><ul><li>核心 DispatchServlet 分发器</li><li>HandlerMapping 映射器</li><li>HandlerAdapter 适配器</li><li>Handler 处理器</li><li>ViewResolver 视图解析器</li><li>View 视图</li></ul><h3 id="DipatcherHandler-准备"><a href="#DipatcherHandler-准备" class="headerlink" title="DipatcherHandler 准备"></a>DipatcherHandler 准备</h3><ul><li>setApplicationContextAware</li><li>initStrategies<ul><li>获取容器中 HandlerMapping 及子接口实现</li><li>获取容器中 HandlerAdapter 及子接口实现</li><li>获取容器中 HandlerResultHandler 及子接口实现</li></ul></li></ul><h3 id="RouterFunctionMapping-实例化"><a href="#RouterFunctionMapping-实例化" class="headerlink" title="RouterFunctionMapping 实例化"></a>RouterFunctionMapping 实例化</h3><ul><li>afterPropertiesSet</li><li>initRouterFunctions </li><li>routerFunctions 获得系统中所有 RouterFunction</li><li>通过 RouterFunction::andOther 将对象合并</li><li>返回 SameComposedRouterFunction 对象</li></ul><h3 id="DispatchHandler-handle"><a href="#DispatchHandler-handle" class="headerlink" title="DispatchHandler#handle"></a>DispatchHandler#handle</h3><ul><li><p>构建基于handlerMappings集合的 Flux 对象</p></li><li><p>通过 contactMap 将其转换成 handler 对象</p></li><li><p>取出第一个 handler 对象，若为空则抛错</p></li><li><p>调用invokeHandler 获得 response</p></li><li><p>调用 handleResult 对结果进行处理</p></li></ul><h3 id="HandlerMapping-getHandler"><a href="#HandlerMapping-getHandler" class="headerlink" title="HandlerMapping#getHandler"></a>HandlerMapping#getHandler</h3><ul><li>调用子类  getHandlerInternal实现</li><li>获得 Handler 对象</li><li>跨域处理</li><li>返回 Mono 对象</li></ul><h3 id="DispatcherHandler-invokeHandler"><a href="#DispatcherHandler-invokeHandler" class="headerlink" title="DispatcherHandler#invokeHandler"></a>DispatcherHandler#invokeHandler</h3><ul><li>遍历handlerAdapters集合</li><li>依次调用集合元素 supports 方法</li><li>调用具体实现类调用 handle 方法</li><li>进入具体 url 对应处理类处理请求</li><li>返回 Mono<HandlerResult> 对象</li></ul><h3 id="DiapatcherHandler-handleResult"><a href="#DiapatcherHandler-handleResult" class="headerlink" title="DiapatcherHandler#handleResult"></a>DiapatcherHandler#handleResult</h3><ul><li>遍历resultHandlers集合</li><li>依次调用集合元素 suportes 方法</li><li>获得具体实现类调用 handleResult 方法</li><li>将请求结果信息写入 ServerWebExchange 对象</li></ul><h2 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h2><ul><li><p>webflux 出现的意义？</p></li><li><p>webflux 与 springmvc 异同？</p></li><li><p>介绍下 reactive streams 规范？</p></li><li><p>介绍一下  reactor </p></li><li><p>flux 和 mono 对象的区别？如何创建</p></li><li><p>reactor 操作符 &amp; 线程池</p></li><li><p>publishOn 和 subsribeOn 区别？切换线程</p></li><li><p>reactor 和 java8 stream 区别</p></li><li><p>webflux 搭建过程，有没有和数据库结合过使用</p></li><li><p>RouterFunctionMapping 的作用以及何时被加载？</p></li><li><p>DispatcherHandler 初始化做了什么事</p></li><li><p>介绍下 DispatcherHandler 的 handle  方法</p></li></ul><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><h2 id="日志介绍"><a href="#日志介绍" class="headerlink" title="日志介绍"></a>日志介绍</h2><h3 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h3><ul><li>记录程序运行轨迹，方便查找问题信息</li></ul><h3 id="日志实现框架"><a href="#日志实现框架" class="headerlink" title="日志实现框架"></a>日志实现框架</h3><ul><li>具体的日志功能实现</li><li>JUL | log4j | logback | log4j2</li></ul><h3 id="日志门面框架"><a href="#日志门面框架" class="headerlink" title="日志门面框架"></a>日志门面框架</h3><ul><li>日志实现的抽象层</li><li>JCL | slf4j</li></ul><h3 id="日志发展过程"><a href="#日志发展过程" class="headerlink" title="日志发展过程"></a>日志发展过程</h3><ul><li>jdk1.3以前 System.(out|err).println</li><li>解决打印缺陷，log4j，2015.8 停止更新</li><li>SUN 公司推出 java.util.logging JUL</li><li>两个系统实现存在兼容问题，推出 commons-logging 即 JCL</li><li>log4j 作者推出 slf4j 成为业界主流</li><li>log4j 作者推出log4j 改进推出logback</li><li>log4j2 对 log4j 的重大升级，修复已知缺陷，极大提升性能</li><li>最佳组合： slf4j + logback(springboot使用)；slf4j + log4j2</li></ul><h3 id="日志实现寻址"><a href="#日志实现寻址" class="headerlink" title="日志实现寻址"></a>日志实现寻址</h3><ul><li>LoggerFactory.getLogger</li><li>findPossibleStaticLoggerBinderPathSet</li><li>获取StaticLoggerBinder 所在 jar 包路径</li><li>若存在多个日志实现框架打印提示及选择</li><li>使用 StaticLoggerBinder 获得日志工厂再得实现 </li></ul><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><h3 id="SpringBoot日志"><a href="#SpringBoot日志" class="headerlink" title="SpringBoot日志"></a>SpringBoot日志</h3><ul><li>spring-boot-starter-logging</li><li>logback-classic</li><li>log4j-to-slf4j</li><li>jul-to-slf4j </li></ul><h3 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h3><ul><li><p>Logger logger = LoggerFactory.getLogger(xx.class)</p></li><li><p>logger.level()</p></li><li><p>ERROR - WARN - INFO - DEBUG - TRACE</p></li><li><p>logger.debug(“xyz” + i + “is” + j)</p></li><li><p>if(logger.isDebugEnabled())</p></li><li><p>logger.debug(“xyz {} is i”,xxx)  官方推荐</p></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>scan 当设置为 true 配置文件若发生改变，将会重新加载</li><li>scanPeriod 扫描时间间隔，若没给出时间单位，默认为毫秒</li><li>debug 若设置为 true，将打印 logback 内部日志信息</li></ul><h3 id="configuration-子节点"><a href="#configuration-子节点" class="headerlink" title="configuration 子节点"></a>configuration 子节点</h3><ul><li>contextName 上下文名称<ul><li><code>&lt;contextName&gt;demo&lt;/contextName&gt;</code></li><li>区分不同应用程序的记录，默认为 default</li></ul></li><li>property 属性配置<ul><li><code>&lt;property name=&quot;LOG_PATH&quot; value=&quot;logs&quot;/&gt;</code></li><li>name 变量名称</li><li>value 变量值</li></ul></li><li>appender 格式化日志输出</li><li>root 全局日志输出设置</li><li>logger 具体包或子类输出设置</li></ul><h3 id="常用-pattern-介绍"><a href="#常用-pattern-介绍" class="headerlink" title="常用 pattern 介绍"></a>常用 pattern 介绍</h3><ul><li>logger {length}: 输出日志的 logger 名。可有一个整形参数，功能是缩短 logger 名</li><li>contextName|cn 上下文名称</li><li>data {pattern}：输出日志的打印时间，模式语法与 java.text.SimpleDateFormat 兼容</li><li>p/le/level：日志级别</li><li>M/method：输出日志的方法名</li><li>r/relative：从程序启动到创建日志记录的时间</li><li>m/msg/message：程序提供的信息</li><li>n：换行符</li></ul><h2 id="日志实战"><a href="#日志实战" class="headerlink" title="日志实战"></a>日志实战</h2><h3 id="日志结合切面"><a href="#日志结合切面" class="headerlink" title="日志结合切面"></a>日志结合切面</h3><ul><li>在 hogback-spring.xml 定义好日志配置</li><li>引入 spring-boot-starter-aop</li><li>定义不同级别的异常类</li><li>编写异常切面类捕获程序抛出错误记录必要信息</li><li>在启动类上加上 EnableAutoApsectProxy</li></ul><h3 id="业务日志分类"><a href="#业务日志分类" class="headerlink" title="业务日志分类"></a>业务日志分类</h3><ul><li>使用 SiftingAppender</li><li>在元素  discriminator 中定义好使用的key</li><li>sift 里给每个业务类型配置 appender</li><li>在程序上下文中通过 MDC 注入业务信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-初识&quot;&gt;&lt;a href=&quot;#SpringBoot-初识&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 初识&quot;&gt;&lt;/a&gt;SpringBoot 初识&lt;/h1&gt;&lt;p&gt;SpringBoot 是 spring 提供的一站式web快速开发部署框架，摆脱 SSM（Spring、Spring-MVC、Mybatis） 繁琐的配置流程，为微服务应运而生。目前有SpringBoot 1.X 和 2.X版本，2.X要求 Java8+，1.x java7 即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://issacyoung.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://issacyoung.cn/tags/java/"/>
    
      <category term="SpringBoot" scheme="http://issacyoung.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>一步步之Discruotor I</title>
    <link href="http://issacyoung.cn/2020/02/24/%E4%B8%80%E6%AD%A5%E6%AD%A5%E4%B9%8BDiscruotor-I/"/>
    <id>http://issacyoung.cn/2020/02/24/%E4%B8%80%E6%AD%A5%E6%AD%A5%E4%B9%8BDiscruotor-I/</id>
    <published>2020-02-24T04:03:30.000Z</published>
    <updated>2020-03-10T00:33:18.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Discruptor-高性能队列"><a href="#Discruptor-高性能队列" class="headerlink" title="Discruptor 高性能队列"></a>Discruptor 高性能队列</h1><p>Discruptor 是一个高性能的异步框架，可以理解为线程间通信的高效低延迟的内存消息队列。而这里说的消息队列，不同于类似 RocketMQ 之类的分布式队列。早期用于英国外汇交易 LMAX ，单线程系统可支撑每秒处理600万订单。目前有很多成熟的项目使用 Disruptor ，比方说 Log4j 2、Camel等。</p><a id="more"></a><p>队列的底层实现是数组、链表或者堆，而堆表示有优先级的</p><h1 id="对比-J-U-C-工具"><a href="#对比-J-U-C-工具" class="headerlink" title="对比 J.U.C 工具"></a>对比 J.U.C 工具</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Discruptor-高性能队列&quot;&gt;&lt;a href=&quot;#Discruptor-高性能队列&quot; class=&quot;headerlink&quot; title=&quot;Discruptor 高性能队列&quot;&gt;&lt;/a&gt;Discruptor 高性能队列&lt;/h1&gt;&lt;p&gt;Discruptor 是一个高性能的异步框架，可以理解为线程间通信的高效低延迟的内存消息队列。而这里说的消息队列，不同于类似 RocketMQ 之类的分布式队列。早期用于英国外汇交易 LMAX ，单线程系统可支撑每秒处理600万订单。目前有很多成熟的项目使用 Disruptor ，比方说 Log4j 2、Camel等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Discruptor" scheme="http://issacyoung.cn/tags/Discruptor/"/>
    
      <category term="一步步" scheme="http://issacyoung.cn/tags/%E4%B8%80%E6%AD%A5%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>如何一步步创建个人网站</title>
    <link href="http://issacyoung.cn/2020/02/22/%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <id>http://issacyoung.cn/2020/02/22/%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</id>
    <published>2020-02-22T14:44:35.000Z</published>
    <updated>2020-02-24T04:04:49.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何一步步创建个人网站"><a href="#如何一步步创建个人网站" class="headerlink" title="如何一步步创建个人网站"></a>如何一步步创建个人网站</h1><blockquote><p>早就想建一个人网站，用于知识积累、感悟心得的记录，得空利用半天周末的时间完成了这个夙愿。</p></blockquote><a id="more"></a><h2 id="获取个人域名"><a href="#获取个人域名" class="headerlink" title="获取个人域名"></a>获取个人域名</h2><p>推荐阿里云申请域名，需要有认证的阿里云账号，审核时间很快，具体步骤阿里云平台有详细的文档。</p><h2 id="Github建立个人仓库"><a href="#Github建立个人仓库" class="headerlink" title="Github建立个人仓库"></a>Github建立个人仓库</h2><p>在 github 代码仓库新建一个仓库，仓库名称参考 *<em>用户名.github.io *</em>，用户名为 github 账号。</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>注意 Node 的版本，Node 下载地址：<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a>。</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>Hexo 是个人博客网站的框架。注意 Hexo 的版本对应的 Node 版本，之前安装因为 Node 版本与 Hexo 版本不一致，有些 Node 的语法不支持，耗费了不少时间。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>基于命令行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 hexo 客户端</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> npm 安装访问境外网站比较慢，推荐设置 npm 镜像为淘宝镜像</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证 npm 的镜像地址</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果还是很慢，可以考虑用 yarn 安装</span></span><br><span class="line">yarn global add hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">hexo -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化 hexo 博客项目</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建博客</span></span><br><span class="line">hexo new/n "我的第一篇个人网站博客"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成/编译</span></span><br><span class="line">hexo generate/n </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务预览</span></span><br><span class="line">hexo server/s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署</span></span><br><span class="line">hexo deploy/d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除缓存</span></span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h3 id="Hexo-测试"><a href="#Hexo-测试" class="headerlink" title="Hexo 测试"></a>Hexo 测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new "我的第一篇个人网站博客"</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务 localhost:4000</span></span><br></pre></td></tr></table></figure><p>打开浏览器输入地址，访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h2 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h2><p>需要将 github 的仓库地址同 Hexo 关联起来，打开项目目录的配置文件 <code>_config.yml</code>，修改部署配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/IssacYoung2013/issacyoung2013.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装 Git 部署插件，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>重新部署服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时访问个人仓库路径，<strong>用户名.github.io</strong>，个人博客网站就可以在网络上访问了。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>在阿里云申请的域名做解析设置</p><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><p>参考文章 <a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661502</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何一步步创建个人网站&quot;&gt;&lt;a href=&quot;#如何一步步创建个人网站&quot; class=&quot;headerlink&quot; title=&quot;如何一步步创建个人网站&quot;&gt;&lt;/a&gt;如何一步步创建个人网站&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;早就想建一个人网站，用于知识积累、感悟心得的记录，得空利用半天周末的时间完成了这个夙愿。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="网站" scheme="http://issacyoung.cn/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="个人博客网站" scheme="http://issacyoung.cn/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    
      <category term="Hexo" scheme="http://issacyoung.cn/tags/Hexo/"/>
    
  </entry>
  
</feed>
